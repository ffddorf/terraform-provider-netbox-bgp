// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_session

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func SessionDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"comments": schema.StringAttribute{
				Computed: true,
			},
			"created": schema.StringAttribute{
				Computed: true,
			},
			"description": schema.StringAttribute{
				Computed: true,
			},
			"device": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"description": schema.StringAttribute{
						Computed: true,
					},
					"display": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: DeviceType{
					ObjectType: types.ObjectType{
						AttrTypes: DeviceValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Adds support for custom fields and tags.",
				MarkdownDescription: "Adds support for custom fields and tags.",
			},
			"display": schema.StringAttribute{
				Computed: true,
			},
			"export_policies": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"comments": schema.StringAttribute{
							Computed: true,
						},
						"description": schema.StringAttribute{
							Computed: true,
						},
						"display": schema.StringAttribute{
							Computed: true,
						},
						"id": schema.Int64Attribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"tags": schema.ListAttribute{
							ElementType: types.StringType,
							Computed:    true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: ExportPoliciesType{
						ObjectType: types.ObjectType{
							AttrTypes: ExportPoliciesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"id": schema.Int64Attribute{
				Required:            true,
				Description:         "A unique integer value identifying this bgp session.",
				MarkdownDescription: "A unique integer value identifying this bgp session.",
			},
			"import_policies": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"comments": schema.StringAttribute{
							Computed: true,
						},
						"description": schema.StringAttribute{
							Computed: true,
						},
						"display": schema.StringAttribute{
							Computed: true,
						},
						"id": schema.Int64Attribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"tags": schema.ListAttribute{
							ElementType: types.StringType,
							Computed:    true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: ImportPoliciesType{
						ObjectType: types.ObjectType{
							AttrTypes: ImportPoliciesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"last_updated": schema.StringAttribute{
				Computed: true,
			},
			"local_address": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"address": schema.StringAttribute{
						Computed: true,
					},
					"description": schema.StringAttribute{
						Computed: true,
					},
					"display": schema.StringAttribute{
						Computed: true,
					},
					"family": schema.Int64Attribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: LocalAddressType{
					ObjectType: types.ObjectType{
						AttrTypes: LocalAddressValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Adds support for custom fields and tags.",
				MarkdownDescription: "Adds support for custom fields and tags.",
			},
			"local_as": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"asn": schema.Int64Attribute{
						Computed:            true,
						Description:         "16- or 32-bit autonomous system number",
						MarkdownDescription: "16- or 32-bit autonomous system number",
					},
					"description": schema.StringAttribute{
						Computed: true,
					},
					"display": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: LocalAsType{
					ObjectType: types.ObjectType{
						AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Adds support for custom fields and tags.",
				MarkdownDescription: "Adds support for custom fields and tags.",
			},
			"name": schema.StringAttribute{
				Computed: true,
			},
			"peer_group": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"description": schema.StringAttribute{
						Computed: true,
					},
					"display": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: PeerGroupType{
					ObjectType: types.ObjectType{
						AttrTypes: PeerGroupValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Adds support for custom fields and tags.",
				MarkdownDescription: "Adds support for custom fields and tags.",
			},
			"prefix_list_in": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"description": schema.StringAttribute{
						Computed: true,
					},
					"display": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: PrefixListInType{
					ObjectType: types.ObjectType{
						AttrTypes: PrefixListInValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Adds support for custom fields and tags.",
				MarkdownDescription: "Adds support for custom fields and tags.",
			},
			"prefix_list_out": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"description": schema.StringAttribute{
						Computed: true,
					},
					"display": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: PrefixListOutType{
					ObjectType: types.ObjectType{
						AttrTypes: PrefixListOutValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Adds support for custom fields and tags.",
				MarkdownDescription: "Adds support for custom fields and tags.",
			},
			"remote_address": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"address": schema.StringAttribute{
						Computed: true,
					},
					"description": schema.StringAttribute{
						Computed: true,
					},
					"display": schema.StringAttribute{
						Computed: true,
					},
					"family": schema.Int64Attribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: RemoteAddressType{
					ObjectType: types.ObjectType{
						AttrTypes: RemoteAddressValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Adds support for custom fields and tags.",
				MarkdownDescription: "Adds support for custom fields and tags.",
			},
			"remote_as": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"asn": schema.Int64Attribute{
						Computed:            true,
						Description:         "16- or 32-bit autonomous system number",
						MarkdownDescription: "16- or 32-bit autonomous system number",
					},
					"description": schema.StringAttribute{
						Computed: true,
					},
					"display": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: RemoteAsType{
					ObjectType: types.ObjectType{
						AttrTypes: RemoteAsValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Adds support for custom fields and tags.",
				MarkdownDescription: "Adds support for custom fields and tags.",
			},
			"site": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"description": schema.StringAttribute{
						Computed: true,
					},
					"display": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed:            true,
						Description:         "Full name of the site",
						MarkdownDescription: "Full name of the site",
					},
					"slug": schema.StringAttribute{
						Computed: true,
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: SiteType{
					ObjectType: types.ObjectType{
						AttrTypes: SiteValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Adds support for custom fields and tags.",
				MarkdownDescription: "Adds support for custom fields and tags.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"label": schema.StringAttribute{
						Computed: true,
					},
					"value": schema.StringAttribute{
						Computed:            true,
						Description:         "* `offline` - Offline\n* `active` - Active\n* `planned` - Planned\n* `failed` - Failed",
						MarkdownDescription: "* `offline` - Offline\n* `active` - Active\n* `planned` - Planned\n* `failed` - Failed",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"tags": schema.ListAttribute{
				ElementType: types.StringType,
				Computed:    true,
			},
			"tenant": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"description": schema.StringAttribute{
						Computed: true,
					},
					"display": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"slug": schema.StringAttribute{
						Computed: true,
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: TenantType{
					ObjectType: types.ObjectType{
						AttrTypes: TenantValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Adds support for custom fields and tags.",
				MarkdownDescription: "Adds support for custom fields and tags.",
			},
			"url": schema.StringAttribute{
				Computed: true,
			},
			"virtualmachine": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"description": schema.StringAttribute{
						Computed: true,
					},
					"display": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: VirtualmachineType{
					ObjectType: types.ObjectType{
						AttrTypes: VirtualmachineValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Adds support for custom fields and tags.",
				MarkdownDescription: "Adds support for custom fields and tags.",
			},
		},
	}
}

type SessionModel struct {
	Comments       types.String        `tfsdk:"comments"`
	Created        types.String        `tfsdk:"created"`
	Description    types.String        `tfsdk:"description"`
	Device         DeviceValue         `tfsdk:"device"`
	Display        types.String        `tfsdk:"display"`
	ExportPolicies types.List          `tfsdk:"export_policies"`
	Id             types.Int64         `tfsdk:"id"`
	ImportPolicies types.List          `tfsdk:"import_policies"`
	LastUpdated    types.String        `tfsdk:"last_updated"`
	LocalAddress   LocalAddressValue   `tfsdk:"local_address"`
	LocalAs        LocalAsValue        `tfsdk:"local_as"`
	Name           types.String        `tfsdk:"name"`
	PeerGroup      PeerGroupValue      `tfsdk:"peer_group"`
	PrefixListIn   PrefixListInValue   `tfsdk:"prefix_list_in"`
	PrefixListOut  PrefixListOutValue  `tfsdk:"prefix_list_out"`
	RemoteAddress  RemoteAddressValue  `tfsdk:"remote_address"`
	RemoteAs       RemoteAsValue       `tfsdk:"remote_as"`
	Site           SiteValue           `tfsdk:"site"`
	Status         StatusValue         `tfsdk:"status"`
	Tags           types.List          `tfsdk:"tags"`
	Tenant         TenantValue         `tfsdk:"tenant"`
	Url            types.String        `tfsdk:"url"`
	Virtualmachine VirtualmachineValue `tfsdk:"virtualmachine"`
}

var _ basetypes.ObjectTypable = DeviceType{}

type DeviceType struct {
	basetypes.ObjectType
}

func (t DeviceType) Equal(o attr.Type) bool {
	other, ok := o.(DeviceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviceType) String() string {
	return "DeviceType"
}

func (t DeviceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviceValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDeviceValueNull() DeviceValue {
	return DeviceValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviceValueUnknown() DeviceValue {
	return DeviceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviceValue Attribute Value",
				"While creating a DeviceValue value, a missing attribute value was detected. "+
					"A DeviceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviceValue Attribute Type",
				"While creating a DeviceValue value, an invalid attribute value was detected. "+
					"A DeviceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviceValue Attribute Value",
				"While creating a DeviceValue value, an extra attribute value was detected. "+
					"A DeviceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviceValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewDeviceValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewDeviceValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDeviceValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDeviceValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewDeviceValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewDeviceValueUnknown(), diags
	}

	return DeviceValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDeviceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviceValue {
	object, diags := NewDeviceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviceValueMust(DeviceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviceType) ValueType(ctx context.Context) attr.Value {
	return DeviceValue{}
}

var _ basetypes.ObjectValuable = DeviceValue{}

type DeviceValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v DeviceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviceValue) String() string {
	return "DeviceValue"
}

func (v DeviceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v DeviceValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v DeviceValue) Type(ctx context.Context) attr.Type {
	return DeviceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ExportPoliciesType{}

type ExportPoliciesType struct {
	basetypes.ObjectType
}

func (t ExportPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(ExportPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExportPoliciesType) String() string {
	return "ExportPoliciesType"
}

func (t ExportPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	commentsAttribute, ok := attributes["comments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`comments is missing from object`)

		return nil, diags
	}

	commentsVal, ok := commentsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`comments expected to be basetypes.StringValue, was: %T`, commentsAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExportPoliciesValue{
		Comments:    commentsVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Tags:        tagsVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewExportPoliciesValueNull() ExportPoliciesValue {
	return ExportPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewExportPoliciesValueUnknown() ExportPoliciesValue {
	return ExportPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExportPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExportPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExportPoliciesValue Attribute Value",
				"While creating a ExportPoliciesValue value, a missing attribute value was detected. "+
					"A ExportPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExportPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExportPoliciesValue Attribute Type",
				"While creating a ExportPoliciesValue value, an invalid attribute value was detected. "+
					"A ExportPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExportPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExportPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExportPoliciesValue Attribute Value",
				"While creating a ExportPoliciesValue value, an extra attribute value was detected. "+
					"A ExportPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExportPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExportPoliciesValueUnknown(), diags
	}

	commentsAttribute, ok := attributes["comments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`comments is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	commentsVal, ok := commentsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`comments expected to be basetypes.StringValue, was: %T`, commentsAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewExportPoliciesValueUnknown(), diags
	}

	return ExportPoliciesValue{
		Comments:    commentsVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Tags:        tagsVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewExportPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExportPoliciesValue {
	object, diags := NewExportPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExportPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExportPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExportPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExportPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExportPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExportPoliciesValueMust(ExportPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExportPoliciesType) ValueType(ctx context.Context) attr.Value {
	return ExportPoliciesValue{}
}

var _ basetypes.ObjectValuable = ExportPoliciesValue{}

type ExportPoliciesValue struct {
	Comments    basetypes.StringValue `tfsdk:"comments"`
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Tags        basetypes.ListValue   `tfsdk:"tags"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v ExportPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["comments"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Comments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["comments"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExportPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExportPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExportPoliciesValue) String() string {
	return "ExportPoliciesValue"
}

func (v ExportPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var tagsVal basetypes.ListValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.ListUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.ListValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"comments":    basetypes.StringType{},
			"description": basetypes.StringType{},
			"display":     basetypes.StringType{},
			"id":          basetypes.Int64Type{},
			"name":        basetypes.StringType{},
			"tags": basetypes.ListType{
				ElemType: types.StringType,
			},
			"url": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"comments":    basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
		"url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"comments":    v.Comments,
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"tags":        tagsVal,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v ExportPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(ExportPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Comments.Equal(other.Comments) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v ExportPoliciesValue) Type(ctx context.Context) attr.Type {
	return ExportPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExportPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"comments":    basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
		"url": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ImportPoliciesType{}

type ImportPoliciesType struct {
	basetypes.ObjectType
}

func (t ImportPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(ImportPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ImportPoliciesType) String() string {
	return "ImportPoliciesType"
}

func (t ImportPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	commentsAttribute, ok := attributes["comments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`comments is missing from object`)

		return nil, diags
	}

	commentsVal, ok := commentsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`comments expected to be basetypes.StringValue, was: %T`, commentsAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ImportPoliciesValue{
		Comments:    commentsVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Tags:        tagsVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewImportPoliciesValueNull() ImportPoliciesValue {
	return ImportPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewImportPoliciesValueUnknown() ImportPoliciesValue {
	return ImportPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewImportPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ImportPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ImportPoliciesValue Attribute Value",
				"While creating a ImportPoliciesValue value, a missing attribute value was detected. "+
					"A ImportPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImportPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ImportPoliciesValue Attribute Type",
				"While creating a ImportPoliciesValue value, an invalid attribute value was detected. "+
					"A ImportPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImportPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ImportPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ImportPoliciesValue Attribute Value",
				"While creating a ImportPoliciesValue value, an extra attribute value was detected. "+
					"A ImportPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ImportPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewImportPoliciesValueUnknown(), diags
	}

	commentsAttribute, ok := attributes["comments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`comments is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	commentsVal, ok := commentsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`comments expected to be basetypes.StringValue, was: %T`, commentsAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewImportPoliciesValueUnknown(), diags
	}

	return ImportPoliciesValue{
		Comments:    commentsVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Tags:        tagsVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewImportPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ImportPoliciesValue {
	object, diags := NewImportPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewImportPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ImportPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewImportPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewImportPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewImportPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewImportPoliciesValueMust(ImportPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ImportPoliciesType) ValueType(ctx context.Context) attr.Value {
	return ImportPoliciesValue{}
}

var _ basetypes.ObjectValuable = ImportPoliciesValue{}

type ImportPoliciesValue struct {
	Comments    basetypes.StringValue `tfsdk:"comments"`
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Tags        basetypes.ListValue   `tfsdk:"tags"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v ImportPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["comments"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Comments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["comments"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ImportPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ImportPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ImportPoliciesValue) String() string {
	return "ImportPoliciesValue"
}

func (v ImportPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var tagsVal basetypes.ListValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.ListUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.ListValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"comments":    basetypes.StringType{},
			"description": basetypes.StringType{},
			"display":     basetypes.StringType{},
			"id":          basetypes.Int64Type{},
			"name":        basetypes.StringType{},
			"tags": basetypes.ListType{
				ElemType: types.StringType,
			},
			"url": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"comments":    basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
		"url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"comments":    v.Comments,
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"tags":        tagsVal,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v ImportPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(ImportPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Comments.Equal(other.Comments) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v ImportPoliciesValue) Type(ctx context.Context) attr.Type {
	return ImportPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ImportPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"comments":    basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
		"url": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LocalAddressType{}

type LocalAddressType struct {
	basetypes.ObjectType
}

func (t LocalAddressType) Equal(o attr.Type) bool {
	other, ok := o.(LocalAddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalAddressType) String() string {
	return "LocalAddressType"
}

func (t LocalAddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	familyAttribute, ok := attributes["family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family is missing from object`)

		return nil, diags
	}

	familyVal, ok := familyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family expected to be basetypes.Int64Value, was: %T`, familyAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalAddressValue{
		Address:     addressVal,
		Description: descriptionVal,
		Display:     displayVal,
		Family:      familyVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLocalAddressValueNull() LocalAddressValue {
	return LocalAddressValue{
		state: attr.ValueStateNull,
	}
}

func NewLocalAddressValueUnknown() LocalAddressValue {
	return LocalAddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalAddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalAddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalAddressValue Attribute Value",
				"While creating a LocalAddressValue value, a missing attribute value was detected. "+
					"A LocalAddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalAddressValue Attribute Type",
				"While creating a LocalAddressValue value, an invalid attribute value was detected. "+
					"A LocalAddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalAddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalAddressValue Attribute Value",
				"While creating a LocalAddressValue value, an extra attribute value was detected. "+
					"A LocalAddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalAddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalAddressValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewLocalAddressValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewLocalAddressValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewLocalAddressValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	familyAttribute, ok := attributes["family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family is missing from object`)

		return NewLocalAddressValueUnknown(), diags
	}

	familyVal, ok := familyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family expected to be basetypes.Int64Value, was: %T`, familyAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewLocalAddressValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewLocalAddressValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewLocalAddressValueUnknown(), diags
	}

	return LocalAddressValue{
		Address:     addressVal,
		Description: descriptionVal,
		Display:     displayVal,
		Family:      familyVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLocalAddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalAddressValue {
	object, diags := NewLocalAddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalAddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalAddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalAddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalAddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalAddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalAddressValueMust(LocalAddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalAddressType) ValueType(ctx context.Context) attr.Value {
	return LocalAddressValue{}
}

var _ basetypes.ObjectValuable = LocalAddressValue{}

type LocalAddressValue struct {
	Address     basetypes.StringValue `tfsdk:"address"`
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Family      basetypes.Int64Value  `tfsdk:"family"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v LocalAddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["family"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Family.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["family"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalAddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalAddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalAddressValue) String() string {
	return "LocalAddressValue"
}

func (v LocalAddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"address":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"family":      basetypes.Int64Type{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address":     v.Address,
			"description": v.Description,
			"display":     v.Display,
			"family":      v.Family,
			"id":          v.Id,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v LocalAddressValue) Equal(o attr.Value) bool {
	other, ok := o.(LocalAddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Family.Equal(other.Family) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v LocalAddressValue) Type(ctx context.Context) attr.Type {
	return LocalAddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalAddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"family":      basetypes.Int64Type{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LocalAsType{}

type LocalAsType struct {
	basetypes.ObjectType
}

func (t LocalAsType) Equal(o attr.Type) bool {
	other, ok := o.(LocalAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalAsType) String() string {
	return "LocalAsType"
}

func (t LocalAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return nil, diags
	}

	asnVal, ok := asnAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.Int64Value, was: %T`, asnAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalAsValue{
		Asn:         asnVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLocalAsValueNull() LocalAsValue {
	return LocalAsValue{
		state: attr.ValueStateNull,
	}
}

func NewLocalAsValueUnknown() LocalAsValue {
	return LocalAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalAsValue Attribute Value",
				"While creating a LocalAsValue value, a missing attribute value was detected. "+
					"A LocalAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalAsValue Attribute Type",
				"While creating a LocalAsValue value, an invalid attribute value was detected. "+
					"A LocalAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalAsValue Attribute Value",
				"While creating a LocalAsValue value, an extra attribute value was detected. "+
					"A LocalAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalAsValueUnknown(), diags
	}

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	asnVal, ok := asnAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.Int64Value, was: %T`, asnAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewLocalAsValueUnknown(), diags
	}

	return LocalAsValue{
		Asn:         asnVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLocalAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalAsValue {
	object, diags := NewLocalAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalAsValueMust(LocalAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalAsType) ValueType(ctx context.Context) attr.Value {
	return LocalAsValue{}
}

var _ basetypes.ObjectValuable = LocalAsValue{}

type LocalAsValue struct {
	Asn         basetypes.Int64Value  `tfsdk:"asn"`
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v LocalAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["asn"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Asn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalAsValue) String() string {
	return "LocalAsValue"
}

func (v LocalAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"asn":         basetypes.Int64Type{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn":         v.Asn,
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v LocalAsValue) Equal(o attr.Value) bool {
	other, ok := o.(LocalAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Asn.Equal(other.Asn) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v LocalAsValue) Type(ctx context.Context) attr.Type {
	return LocalAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn":         basetypes.Int64Type{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PeerGroupType{}

type PeerGroupType struct {
	basetypes.ObjectType
}

func (t PeerGroupType) Equal(o attr.Type) bool {
	other, ok := o.(PeerGroupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PeerGroupType) String() string {
	return "PeerGroupType"
}

func (t PeerGroupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PeerGroupValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPeerGroupValueNull() PeerGroupValue {
	return PeerGroupValue{
		state: attr.ValueStateNull,
	}
}

func NewPeerGroupValueUnknown() PeerGroupValue {
	return PeerGroupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPeerGroupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PeerGroupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PeerGroupValue Attribute Value",
				"While creating a PeerGroupValue value, a missing attribute value was detected. "+
					"A PeerGroupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PeerGroupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PeerGroupValue Attribute Type",
				"While creating a PeerGroupValue value, an invalid attribute value was detected. "+
					"A PeerGroupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PeerGroupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PeerGroupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PeerGroupValue Attribute Value",
				"While creating a PeerGroupValue value, an extra attribute value was detected. "+
					"A PeerGroupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PeerGroupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPeerGroupValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPeerGroupValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewPeerGroupValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewPeerGroupValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPeerGroupValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewPeerGroupValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewPeerGroupValueUnknown(), diags
	}

	return PeerGroupValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPeerGroupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PeerGroupValue {
	object, diags := NewPeerGroupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPeerGroupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PeerGroupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPeerGroupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPeerGroupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPeerGroupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPeerGroupValueMust(PeerGroupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PeerGroupType) ValueType(ctx context.Context) attr.Value {
	return PeerGroupValue{}
}

var _ basetypes.ObjectValuable = PeerGroupValue{}

type PeerGroupValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v PeerGroupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PeerGroupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PeerGroupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PeerGroupValue) String() string {
	return "PeerGroupValue"
}

func (v PeerGroupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v PeerGroupValue) Equal(o attr.Value) bool {
	other, ok := o.(PeerGroupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v PeerGroupValue) Type(ctx context.Context) attr.Type {
	return PeerGroupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PeerGroupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PrefixListInType{}

type PrefixListInType struct {
	basetypes.ObjectType
}

func (t PrefixListInType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixListInType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixListInType) String() string {
	return "PrefixListInType"
}

func (t PrefixListInType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixListInValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrefixListInValueNull() PrefixListInValue {
	return PrefixListInValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixListInValueUnknown() PrefixListInValue {
	return PrefixListInValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixListInValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixListInValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixListInValue Attribute Value",
				"While creating a PrefixListInValue value, a missing attribute value was detected. "+
					"A PrefixListInValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixListInValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixListInValue Attribute Type",
				"While creating a PrefixListInValue value, an invalid attribute value was detected. "+
					"A PrefixListInValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixListInValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixListInValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixListInValue Attribute Value",
				"While creating a PrefixListInValue value, an extra attribute value was detected. "+
					"A PrefixListInValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixListInValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixListInValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPrefixListInValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewPrefixListInValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewPrefixListInValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPrefixListInValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewPrefixListInValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewPrefixListInValueUnknown(), diags
	}

	return PrefixListInValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrefixListInValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixListInValue {
	object, diags := NewPrefixListInValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixListInValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixListInType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixListInValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixListInValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixListInValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixListInValueMust(PrefixListInValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixListInType) ValueType(ctx context.Context) attr.Value {
	return PrefixListInValue{}
}

var _ basetypes.ObjectValuable = PrefixListInValue{}

type PrefixListInValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v PrefixListInValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixListInValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixListInValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixListInValue) String() string {
	return "PrefixListInValue"
}

func (v PrefixListInValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v PrefixListInValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixListInValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v PrefixListInValue) Type(ctx context.Context) attr.Type {
	return PrefixListInType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixListInValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PrefixListOutType{}

type PrefixListOutType struct {
	basetypes.ObjectType
}

func (t PrefixListOutType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixListOutType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixListOutType) String() string {
	return "PrefixListOutType"
}

func (t PrefixListOutType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixListOutValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrefixListOutValueNull() PrefixListOutValue {
	return PrefixListOutValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixListOutValueUnknown() PrefixListOutValue {
	return PrefixListOutValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixListOutValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixListOutValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixListOutValue Attribute Value",
				"While creating a PrefixListOutValue value, a missing attribute value was detected. "+
					"A PrefixListOutValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixListOutValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixListOutValue Attribute Type",
				"While creating a PrefixListOutValue value, an invalid attribute value was detected. "+
					"A PrefixListOutValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixListOutValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixListOutValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixListOutValue Attribute Value",
				"While creating a PrefixListOutValue value, an extra attribute value was detected. "+
					"A PrefixListOutValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixListOutValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixListOutValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPrefixListOutValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewPrefixListOutValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewPrefixListOutValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPrefixListOutValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewPrefixListOutValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewPrefixListOutValueUnknown(), diags
	}

	return PrefixListOutValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrefixListOutValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixListOutValue {
	object, diags := NewPrefixListOutValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixListOutValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixListOutType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixListOutValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixListOutValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixListOutValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixListOutValueMust(PrefixListOutValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixListOutType) ValueType(ctx context.Context) attr.Value {
	return PrefixListOutValue{}
}

var _ basetypes.ObjectValuable = PrefixListOutValue{}

type PrefixListOutValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v PrefixListOutValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixListOutValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixListOutValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixListOutValue) String() string {
	return "PrefixListOutValue"
}

func (v PrefixListOutValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v PrefixListOutValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixListOutValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v PrefixListOutValue) Type(ctx context.Context) attr.Type {
	return PrefixListOutType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixListOutValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RemoteAddressType{}

type RemoteAddressType struct {
	basetypes.ObjectType
}

func (t RemoteAddressType) Equal(o attr.Type) bool {
	other, ok := o.(RemoteAddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemoteAddressType) String() string {
	return "RemoteAddressType"
}

func (t RemoteAddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	familyAttribute, ok := attributes["family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family is missing from object`)

		return nil, diags
	}

	familyVal, ok := familyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family expected to be basetypes.Int64Value, was: %T`, familyAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemoteAddressValue{
		Address:     addressVal,
		Description: descriptionVal,
		Display:     displayVal,
		Family:      familyVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRemoteAddressValueNull() RemoteAddressValue {
	return RemoteAddressValue{
		state: attr.ValueStateNull,
	}
}

func NewRemoteAddressValueUnknown() RemoteAddressValue {
	return RemoteAddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemoteAddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemoteAddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemoteAddressValue Attribute Value",
				"While creating a RemoteAddressValue value, a missing attribute value was detected. "+
					"A RemoteAddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteAddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemoteAddressValue Attribute Type",
				"While creating a RemoteAddressValue value, an invalid attribute value was detected. "+
					"A RemoteAddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteAddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemoteAddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemoteAddressValue Attribute Value",
				"While creating a RemoteAddressValue value, an extra attribute value was detected. "+
					"A RemoteAddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemoteAddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemoteAddressValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewRemoteAddressValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewRemoteAddressValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewRemoteAddressValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	familyAttribute, ok := attributes["family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family is missing from object`)

		return NewRemoteAddressValueUnknown(), diags
	}

	familyVal, ok := familyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family expected to be basetypes.Int64Value, was: %T`, familyAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewRemoteAddressValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewRemoteAddressValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewRemoteAddressValueUnknown(), diags
	}

	return RemoteAddressValue{
		Address:     addressVal,
		Description: descriptionVal,
		Display:     displayVal,
		Family:      familyVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRemoteAddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemoteAddressValue {
	object, diags := NewRemoteAddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemoteAddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemoteAddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemoteAddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemoteAddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemoteAddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemoteAddressValueMust(RemoteAddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemoteAddressType) ValueType(ctx context.Context) attr.Value {
	return RemoteAddressValue{}
}

var _ basetypes.ObjectValuable = RemoteAddressValue{}

type RemoteAddressValue struct {
	Address     basetypes.StringValue `tfsdk:"address"`
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Family      basetypes.Int64Value  `tfsdk:"family"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v RemoteAddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["family"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Family.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["family"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemoteAddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemoteAddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemoteAddressValue) String() string {
	return "RemoteAddressValue"
}

func (v RemoteAddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"address":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"family":      basetypes.Int64Type{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address":     v.Address,
			"description": v.Description,
			"display":     v.Display,
			"family":      v.Family,
			"id":          v.Id,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v RemoteAddressValue) Equal(o attr.Value) bool {
	other, ok := o.(RemoteAddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Family.Equal(other.Family) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v RemoteAddressValue) Type(ctx context.Context) attr.Type {
	return RemoteAddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemoteAddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"family":      basetypes.Int64Type{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RemoteAsType{}

type RemoteAsType struct {
	basetypes.ObjectType
}

func (t RemoteAsType) Equal(o attr.Type) bool {
	other, ok := o.(RemoteAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemoteAsType) String() string {
	return "RemoteAsType"
}

func (t RemoteAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return nil, diags
	}

	asnVal, ok := asnAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.Int64Value, was: %T`, asnAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemoteAsValue{
		Asn:         asnVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRemoteAsValueNull() RemoteAsValue {
	return RemoteAsValue{
		state: attr.ValueStateNull,
	}
}

func NewRemoteAsValueUnknown() RemoteAsValue {
	return RemoteAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemoteAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemoteAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemoteAsValue Attribute Value",
				"While creating a RemoteAsValue value, a missing attribute value was detected. "+
					"A RemoteAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemoteAsValue Attribute Type",
				"While creating a RemoteAsValue value, an invalid attribute value was detected. "+
					"A RemoteAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemoteAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemoteAsValue Attribute Value",
				"While creating a RemoteAsValue value, an extra attribute value was detected. "+
					"A RemoteAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemoteAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemoteAsValueUnknown(), diags
	}

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return NewRemoteAsValueUnknown(), diags
	}

	asnVal, ok := asnAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.Int64Value, was: %T`, asnAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewRemoteAsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewRemoteAsValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewRemoteAsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewRemoteAsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewRemoteAsValueUnknown(), diags
	}

	return RemoteAsValue{
		Asn:         asnVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRemoteAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemoteAsValue {
	object, diags := NewRemoteAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemoteAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemoteAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemoteAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemoteAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemoteAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemoteAsValueMust(RemoteAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemoteAsType) ValueType(ctx context.Context) attr.Value {
	return RemoteAsValue{}
}

var _ basetypes.ObjectValuable = RemoteAsValue{}

type RemoteAsValue struct {
	Asn         basetypes.Int64Value  `tfsdk:"asn"`
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v RemoteAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["asn"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Asn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemoteAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemoteAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemoteAsValue) String() string {
	return "RemoteAsValue"
}

func (v RemoteAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"asn":         basetypes.Int64Type{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn":         v.Asn,
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v RemoteAsValue) Equal(o attr.Value) bool {
	other, ok := o.(RemoteAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Asn.Equal(other.Asn) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v RemoteAsValue) Type(ctx context.Context) attr.Type {
	return RemoteAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemoteAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn":         basetypes.Int64Type{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SiteType{}

type SiteType struct {
	basetypes.ObjectType
}

func (t SiteType) Equal(o attr.Type) bool {
	other, ok := o.(SiteType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SiteType) String() string {
	return "SiteType"
}

func (t SiteType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SiteValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Slug:        slugVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSiteValueNull() SiteValue {
	return SiteValue{
		state: attr.ValueStateNull,
	}
}

func NewSiteValueUnknown() SiteValue {
	return SiteValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSiteValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SiteValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SiteValue Attribute Value",
				"While creating a SiteValue value, a missing attribute value was detected. "+
					"A SiteValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SiteValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SiteValue Attribute Type",
				"While creating a SiteValue value, an invalid attribute value was detected. "+
					"A SiteValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SiteValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SiteValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SiteValue Attribute Value",
				"While creating a SiteValue value, an extra attribute value was detected. "+
					"A SiteValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SiteValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSiteValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSiteValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewSiteValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewSiteValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSiteValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewSiteValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSiteValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewSiteValueUnknown(), diags
	}

	return SiteValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Slug:        slugVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSiteValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SiteValue {
	object, diags := NewSiteValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSiteValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SiteType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSiteValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSiteValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSiteValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSiteValueMust(SiteValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SiteType) ValueType(ctx context.Context) attr.Value {
	return SiteValue{}
}

var _ basetypes.ObjectValuable = SiteValue{}

type SiteValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Slug        basetypes.StringValue `tfsdk:"slug"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v SiteValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SiteValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SiteValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SiteValue) String() string {
	return "SiteValue"
}

func (v SiteValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"slug":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"slug":        v.Slug,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v SiteValue) Equal(o attr.Value) bool {
	other, ok := o.(SiteValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v SiteValue) Type(ctx context.Context) attr.Type {
	return SiteType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SiteValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"slug":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return nil, diags
	}

	labelVal, ok := labelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be basetypes.StringValue, was: %T`, labelAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Label: labelVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	labelVal, ok := labelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be basetypes.StringValue, was: %T`, labelAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Label: labelVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Label basetypes.StringValue `tfsdk:"label"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["label"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Label.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["label"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"label": basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"label": v.Label,
			"value": v.Value,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Label.Equal(other.Label) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"label": basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TenantType{}

type TenantType struct {
	basetypes.ObjectType
}

func (t TenantType) Equal(o attr.Type) bool {
	other, ok := o.(TenantType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TenantType) String() string {
	return "TenantType"
}

func (t TenantType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TenantValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Slug:        slugVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTenantValueNull() TenantValue {
	return TenantValue{
		state: attr.ValueStateNull,
	}
}

func NewTenantValueUnknown() TenantValue {
	return TenantValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTenantValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TenantValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TenantValue Attribute Value",
				"While creating a TenantValue value, a missing attribute value was detected. "+
					"A TenantValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TenantValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TenantValue Attribute Type",
				"While creating a TenantValue value, an invalid attribute value was detected. "+
					"A TenantValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TenantValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TenantValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TenantValue Attribute Value",
				"While creating a TenantValue value, an extra attribute value was detected. "+
					"A TenantValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TenantValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTenantValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewTenantValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewTenantValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewTenantValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTenantValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewTenantValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewTenantValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewTenantValueUnknown(), diags
	}

	return TenantValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Slug:        slugVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTenantValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TenantValue {
	object, diags := NewTenantValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTenantValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TenantType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTenantValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTenantValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTenantValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTenantValueMust(TenantValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TenantType) ValueType(ctx context.Context) attr.Value {
	return TenantValue{}
}

var _ basetypes.ObjectValuable = TenantValue{}

type TenantValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Slug        basetypes.StringValue `tfsdk:"slug"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v TenantValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TenantValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TenantValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TenantValue) String() string {
	return "TenantValue"
}

func (v TenantValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"slug":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"slug":        v.Slug,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v TenantValue) Equal(o attr.Value) bool {
	other, ok := o.(TenantValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v TenantValue) Type(ctx context.Context) attr.Type {
	return TenantType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TenantValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"slug":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VirtualmachineType{}

type VirtualmachineType struct {
	basetypes.ObjectType
}

func (t VirtualmachineType) Equal(o attr.Type) bool {
	other, ok := o.(VirtualmachineType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VirtualmachineType) String() string {
	return "VirtualmachineType"
}

func (t VirtualmachineType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VirtualmachineValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVirtualmachineValueNull() VirtualmachineValue {
	return VirtualmachineValue{
		state: attr.ValueStateNull,
	}
}

func NewVirtualmachineValueUnknown() VirtualmachineValue {
	return VirtualmachineValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVirtualmachineValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VirtualmachineValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VirtualmachineValue Attribute Value",
				"While creating a VirtualmachineValue value, a missing attribute value was detected. "+
					"A VirtualmachineValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VirtualmachineValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VirtualmachineValue Attribute Type",
				"While creating a VirtualmachineValue value, an invalid attribute value was detected. "+
					"A VirtualmachineValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VirtualmachineValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VirtualmachineValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VirtualmachineValue Attribute Value",
				"While creating a VirtualmachineValue value, an extra attribute value was detected. "+
					"A VirtualmachineValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VirtualmachineValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVirtualmachineValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewVirtualmachineValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewVirtualmachineValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewVirtualmachineValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVirtualmachineValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewVirtualmachineValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewVirtualmachineValueUnknown(), diags
	}

	return VirtualmachineValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVirtualmachineValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VirtualmachineValue {
	object, diags := NewVirtualmachineValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVirtualmachineValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VirtualmachineType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVirtualmachineValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVirtualmachineValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVirtualmachineValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVirtualmachineValueMust(VirtualmachineValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VirtualmachineType) ValueType(ctx context.Context) attr.Value {
	return VirtualmachineValue{}
}

var _ basetypes.ObjectValuable = VirtualmachineValue{}

type VirtualmachineValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v VirtualmachineValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VirtualmachineValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VirtualmachineValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VirtualmachineValue) String() string {
	return "VirtualmachineValue"
}

func (v VirtualmachineValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v VirtualmachineValue) Equal(o attr.Value) bool {
	other, ok := o.(VirtualmachineValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v VirtualmachineValue) Type(ctx context.Context) attr.Type {
	return VirtualmachineType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VirtualmachineValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}
