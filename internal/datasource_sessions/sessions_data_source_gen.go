// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_sessions

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func SessionsDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"by_local_address": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Local Address",
				MarkdownDescription: "Local Address",
			},
			"by_remote_address": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Remote Address",
				MarkdownDescription: "Remote Address",
			},
			"count": schema.Int64Attribute{
				Computed: true,
			},
			"created": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"created__empty": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"created__gt": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"created__gte": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"created__lt": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"created__lte": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"created__n": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"created_by_request": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"description": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"description__empty": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"description__ic": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"description__ie": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"description__iew": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"description__iregex": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"description__isw": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"description__n": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"description__nic": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"description__nie": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"description__niew": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"description__nisw": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"description__regex": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"device": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Device (name)",
				MarkdownDescription: "Device (name)",
			},
			"device__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Device (name)",
				MarkdownDescription: "Device (name)",
			},
			"device_id": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Device (ID)",
				MarkdownDescription: "Device (ID)",
			},
			"device_id__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Device (ID)",
				MarkdownDescription: "Device (ID)",
			},
			"export_policies": schema.ListAttribute{
				ElementType: types.Int64Type,
				Optional:    true,
				Computed:    true,
			},
			"export_policies__n": schema.ListAttribute{
				ElementType: types.Int64Type,
				Optional:    true,
				Computed:    true,
			},
			"id": schema.ListAttribute{
				ElementType: types.Int64Type,
				Optional:    true,
				Computed:    true,
			},
			"id__empty": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"id__gt": schema.ListAttribute{
				ElementType: types.Int64Type,
				Optional:    true,
				Computed:    true,
			},
			"id__gte": schema.ListAttribute{
				ElementType: types.Int64Type,
				Optional:    true,
				Computed:    true,
			},
			"id__lt": schema.ListAttribute{
				ElementType: types.Int64Type,
				Optional:    true,
				Computed:    true,
			},
			"id__lte": schema.ListAttribute{
				ElementType: types.Int64Type,
				Optional:    true,
				Computed:    true,
			},
			"id__n": schema.ListAttribute{
				ElementType: types.Int64Type,
				Optional:    true,
				Computed:    true,
			},
			"import_policies": schema.ListAttribute{
				ElementType: types.Int64Type,
				Optional:    true,
				Computed:    true,
			},
			"import_policies__n": schema.ListAttribute{
				ElementType: types.Int64Type,
				Optional:    true,
				Computed:    true,
			},
			"last_updated": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"last_updated__empty": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"last_updated__gt": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"last_updated__gte": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"last_updated__lt": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"last_updated__lte": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"last_updated__n": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"limit": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of results to return per page.",
				MarkdownDescription: "Number of results to return per page.",
			},
			"local_address": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Local Address",
				MarkdownDescription: "Local Address",
			},
			"local_address__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Local Address",
				MarkdownDescription: "Local Address",
			},
			"local_address_id": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Local Address (ID)",
				MarkdownDescription: "Local Address (ID)",
			},
			"local_address_id__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Local Address (ID)",
				MarkdownDescription: "Local Address (ID)",
			},
			"local_as": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Local AS (Number)",
				MarkdownDescription: "Local AS (Number)",
			},
			"local_as__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Local AS (Number)",
				MarkdownDescription: "Local AS (Number)",
			},
			"local_as_id": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Local AS (ID)",
				MarkdownDescription: "Local AS (ID)",
			},
			"local_as_id__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Local AS (ID)",
				MarkdownDescription: "Local AS (ID)",
			},
			"modified_by_request": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"name": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"name__empty": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"name__ic": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"name__ie": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"name__iew": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"name__iregex": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"name__isw": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"name__n": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"name__nic": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"name__nie": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"name__niew": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"name__nisw": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"name__regex": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"offset": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The initial index from which to return the results.",
				MarkdownDescription: "The initial index from which to return the results.",
			},
			"ordering": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Which field to use when ordering the results.",
				MarkdownDescription: "Which field to use when ordering the results.",
			},
			"peer_group": schema.ListAttribute{
				ElementType: types.Int64Type,
				Optional:    true,
				Computed:    true,
			},
			"peer_group__n": schema.ListAttribute{
				ElementType: types.Int64Type,
				Optional:    true,
				Computed:    true,
			},
			"q": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Search",
				MarkdownDescription: "Search",
			},
			"remote_address": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Remote Address",
				MarkdownDescription: "Remote Address",
			},
			"remote_address__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Remote Address",
				MarkdownDescription: "Remote Address",
			},
			"remote_address_id": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Remote Address (ID)",
				MarkdownDescription: "Remote Address (ID)",
			},
			"remote_address_id__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Remote Address (ID)",
				MarkdownDescription: "Remote Address (ID)",
			},
			"remote_as": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Remote AS (Number)",
				MarkdownDescription: "Remote AS (Number)",
			},
			"remote_as__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Remote AS (Number)",
				MarkdownDescription: "Remote AS (Number)",
			},
			"remote_as_id": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Remote AS (ID)",
				MarkdownDescription: "Remote AS (ID)",
			},
			"remote_as_id__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Remote AS (ID)",
				MarkdownDescription: "Remote AS (ID)",
			},
			"results": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"comments": schema.StringAttribute{
							Computed: true,
						},
						"created": schema.StringAttribute{
							Computed: true,
						},
						"description": schema.StringAttribute{
							Computed: true,
						},
						"device": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Computed: true,
								},
								"display": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"url": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: DeviceType{
								ObjectType: types.ObjectType{
									AttrTypes: DeviceValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Adds support for custom fields and tags.",
							MarkdownDescription: "Adds support for custom fields and tags.",
						},
						"display": schema.StringAttribute{
							Computed: true,
						},
						"export_policies": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"comments": schema.StringAttribute{
										Computed: true,
									},
									"description": schema.StringAttribute{
										Computed: true,
									},
									"display": schema.StringAttribute{
										Computed: true,
									},
									"id": schema.Int64Attribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"tags": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ExportPoliciesType{
									ObjectType: types.ObjectType{
										AttrTypes: ExportPoliciesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"id": schema.Int64Attribute{
							Computed: true,
						},
						"import_policies": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"comments": schema.StringAttribute{
										Computed: true,
									},
									"description": schema.StringAttribute{
										Computed: true,
									},
									"display": schema.StringAttribute{
										Computed: true,
									},
									"id": schema.Int64Attribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"tags": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ImportPoliciesType{
									ObjectType: types.ObjectType{
										AttrTypes: ImportPoliciesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"last_updated": schema.StringAttribute{
							Computed: true,
						},
						"local_address": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"address": schema.StringAttribute{
									Computed: true,
								},
								"description": schema.StringAttribute{
									Computed: true,
								},
								"display": schema.StringAttribute{
									Computed: true,
								},
								"family": schema.Int64Attribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"url": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: LocalAddressType{
								ObjectType: types.ObjectType{
									AttrTypes: LocalAddressValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Adds support for custom fields and tags.",
							MarkdownDescription: "Adds support for custom fields and tags.",
						},
						"local_as": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"asn": schema.Int64Attribute{
									Computed:            true,
									Description:         "16- or 32-bit autonomous system number",
									MarkdownDescription: "16- or 32-bit autonomous system number",
								},
								"description": schema.StringAttribute{
									Computed: true,
								},
								"display": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"url": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: LocalAsType{
								ObjectType: types.ObjectType{
									AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Adds support for custom fields and tags.",
							MarkdownDescription: "Adds support for custom fields and tags.",
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"peer_group": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Computed: true,
								},
								"display": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"url": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: PeerGroupType{
								ObjectType: types.ObjectType{
									AttrTypes: PeerGroupValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Adds support for custom fields and tags.",
							MarkdownDescription: "Adds support for custom fields and tags.",
						},
						"prefix_list_in": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Computed: true,
								},
								"display": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"url": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: PrefixListInType{
								ObjectType: types.ObjectType{
									AttrTypes: PrefixListInValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Adds support for custom fields and tags.",
							MarkdownDescription: "Adds support for custom fields and tags.",
						},
						"prefix_list_out": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Computed: true,
								},
								"display": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"url": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: PrefixListOutType{
								ObjectType: types.ObjectType{
									AttrTypes: PrefixListOutValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Adds support for custom fields and tags.",
							MarkdownDescription: "Adds support for custom fields and tags.",
						},
						"remote_address": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"address": schema.StringAttribute{
									Computed: true,
								},
								"description": schema.StringAttribute{
									Computed: true,
								},
								"display": schema.StringAttribute{
									Computed: true,
								},
								"family": schema.Int64Attribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"url": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: RemoteAddressType{
								ObjectType: types.ObjectType{
									AttrTypes: RemoteAddressValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Adds support for custom fields and tags.",
							MarkdownDescription: "Adds support for custom fields and tags.",
						},
						"remote_as": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"asn": schema.Int64Attribute{
									Computed:            true,
									Description:         "16- or 32-bit autonomous system number",
									MarkdownDescription: "16- or 32-bit autonomous system number",
								},
								"description": schema.StringAttribute{
									Computed: true,
								},
								"display": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"url": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: RemoteAsType{
								ObjectType: types.ObjectType{
									AttrTypes: RemoteAsValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Adds support for custom fields and tags.",
							MarkdownDescription: "Adds support for custom fields and tags.",
						},
						"site": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Computed: true,
								},
								"display": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed:            true,
									Description:         "Full name of the site",
									MarkdownDescription: "Full name of the site",
								},
								"slug": schema.StringAttribute{
									Computed: true,
								},
								"url": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: SiteType{
								ObjectType: types.ObjectType{
									AttrTypes: SiteValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Adds support for custom fields and tags.",
							MarkdownDescription: "Adds support for custom fields and tags.",
						},
						"status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"label": schema.StringAttribute{
									Computed: true,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									Description:         "* `offline` - Offline\n* `active` - Active\n* `planned` - Planned\n* `failed` - Failed",
									MarkdownDescription: "* `offline` - Offline\n* `active` - Active\n* `planned` - Planned\n* `failed` - Failed",
								},
							},
							CustomType: StatusType{
								ObjectType: types.ObjectType{
									AttrTypes: StatusValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"tags": schema.ListAttribute{
							ElementType: types.StringType,
							Computed:    true,
						},
						"tenant": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Computed: true,
								},
								"display": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"slug": schema.StringAttribute{
									Computed: true,
								},
								"url": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: TenantType{
								ObjectType: types.ObjectType{
									AttrTypes: TenantValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Adds support for custom fields and tags.",
							MarkdownDescription: "Adds support for custom fields and tags.",
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
						"virtualmachine": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Computed: true,
								},
								"display": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"url": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: VirtualmachineType{
								ObjectType: types.ObjectType{
									AttrTypes: VirtualmachineValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Adds support for custom fields and tags.",
							MarkdownDescription: "Adds support for custom fields and tags.",
						},
					},
					CustomType: ResultsType{
						ObjectType: types.ObjectType{
							AttrTypes: ResultsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"site": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "DSite (name)",
				MarkdownDescription: "DSite (name)",
			},
			"site__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "DSite (name)",
				MarkdownDescription: "DSite (name)",
			},
			"site_id": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Site (ID)",
				MarkdownDescription: "Site (ID)",
			},
			"site_id__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Site (ID)",
				MarkdownDescription: "Site (ID)",
			},
			"status": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "* `offline` - Offline\n* `active` - Active\n* `planned` - Planned\n* `failed` - Failed",
				MarkdownDescription: "* `offline` - Offline\n* `active` - Active\n* `planned` - Planned\n* `failed` - Failed",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"active",
						"failed",
						"null",
						"offline",
						"planned",
					),
				},
			},
			"tag": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"tag__n": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"tag_id": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"tag_id__n": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"tenant": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Tenant (slug)",
				MarkdownDescription: "Tenant (slug)",
			},
			"tenant__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Tenant (slug)",
				MarkdownDescription: "Tenant (slug)",
			},
			"tenant_group": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"tenant_group__n": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"tenant_group_id": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"tenant_group_id__n": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"tenant_id": schema.ListAttribute{
				ElementType:         types.Int64Type,
				Optional:            true,
				Computed:            true,
				Description:         "Tenant (ID)",
				MarkdownDescription: "Tenant (ID)",
			},
			"tenant_id__n": schema.ListAttribute{
				ElementType:         types.Int64Type,
				Optional:            true,
				Computed:            true,
				Description:         "Tenant (ID)",
				MarkdownDescription: "Tenant (ID)",
			},
			"updated_by_request": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"virtualmachine": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "VirtualMachine (name)",
				MarkdownDescription: "VirtualMachine (name)",
			},
			"virtualmachine__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "VirtualMachine (name)",
				MarkdownDescription: "VirtualMachine (name)",
			},
			"virtualmachine_id": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "VirtualMachine (ID)",
				MarkdownDescription: "VirtualMachine (ID)",
			},
			"virtualmachine_id__n": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "VirtualMachine (ID)",
				MarkdownDescription: "VirtualMachine (ID)",
			},
		},
	}
}

type SessionsModel struct {
	ByLocalAddress     types.String `tfsdk:"by_local_address"`
	ByRemoteAddress    types.String `tfsdk:"by_remote_address"`
	Count              types.Int64  `tfsdk:"count"`
	Created            types.List   `tfsdk:"created"`
	Created_Empty      types.List   `tfsdk:"created__empty"`
	Created_Gt         types.List   `tfsdk:"created__gt"`
	Created_Gte        types.List   `tfsdk:"created__gte"`
	Created_Lt         types.List   `tfsdk:"created__lt"`
	Created_Lte        types.List   `tfsdk:"created__lte"`
	Created_N          types.List   `tfsdk:"created__n"`
	CreatedByRequest   types.String `tfsdk:"created_by_request"`
	Description        types.List   `tfsdk:"description"`
	Description_Empty  types.Bool   `tfsdk:"description__empty"`
	Description_Ic     types.List   `tfsdk:"description__ic"`
	Description_Ie     types.List   `tfsdk:"description__ie"`
	Description_Iew    types.List   `tfsdk:"description__iew"`
	Description_Iregex types.List   `tfsdk:"description__iregex"`
	Description_Isw    types.List   `tfsdk:"description__isw"`
	Description_N      types.List   `tfsdk:"description__n"`
	Description_Nic    types.List   `tfsdk:"description__nic"`
	Description_Nie    types.List   `tfsdk:"description__nie"`
	Description_Niew   types.List   `tfsdk:"description__niew"`
	Description_Nisw   types.List   `tfsdk:"description__nisw"`
	Description_Regex  types.List   `tfsdk:"description__regex"`
	Device             types.List   `tfsdk:"device"`
	Device_N           types.List   `tfsdk:"device__n"`
	DeviceId           types.List   `tfsdk:"device_id"`
	DeviceId_N         types.List   `tfsdk:"device_id__n"`
	ExportPolicies     types.List   `tfsdk:"export_policies"`
	ExportPolicies_N   types.List   `tfsdk:"export_policies__n"`
	Id                 types.List   `tfsdk:"id"`
	Id_Empty           types.Bool   `tfsdk:"id__empty"`
	Id_Gt              types.List   `tfsdk:"id__gt"`
	Id_Gte             types.List   `tfsdk:"id__gte"`
	Id_Lt              types.List   `tfsdk:"id__lt"`
	Id_Lte             types.List   `tfsdk:"id__lte"`
	Id_N               types.List   `tfsdk:"id__n"`
	ImportPolicies     types.List   `tfsdk:"import_policies"`
	ImportPolicies_N   types.List   `tfsdk:"import_policies__n"`
	LastUpdated        types.List   `tfsdk:"last_updated"`
	LastUpdated_Empty  types.List   `tfsdk:"last_updated__empty"`
	LastUpdated_Gt     types.List   `tfsdk:"last_updated__gt"`
	LastUpdated_Gte    types.List   `tfsdk:"last_updated__gte"`
	LastUpdated_Lt     types.List   `tfsdk:"last_updated__lt"`
	LastUpdated_Lte    types.List   `tfsdk:"last_updated__lte"`
	LastUpdated_N      types.List   `tfsdk:"last_updated__n"`
	Limit              types.Int64  `tfsdk:"limit"`
	LocalAddress       types.List   `tfsdk:"local_address"`
	LocalAddress_N     types.List   `tfsdk:"local_address__n"`
	LocalAddressId     types.List   `tfsdk:"local_address_id"`
	LocalAddressId_N   types.List   `tfsdk:"local_address_id__n"`
	LocalAs            types.List   `tfsdk:"local_as"`
	LocalAs_N          types.List   `tfsdk:"local_as__n"`
	LocalAsId          types.List   `tfsdk:"local_as_id"`
	LocalAsId_N        types.List   `tfsdk:"local_as_id__n"`
	ModifiedByRequest  types.String `tfsdk:"modified_by_request"`
	Name               types.List   `tfsdk:"name"`
	Name_Empty         types.Bool   `tfsdk:"name__empty"`
	Name_Ic            types.List   `tfsdk:"name__ic"`
	Name_Ie            types.List   `tfsdk:"name__ie"`
	Name_Iew           types.List   `tfsdk:"name__iew"`
	Name_Iregex        types.List   `tfsdk:"name__iregex"`
	Name_Isw           types.List   `tfsdk:"name__isw"`
	Name_N             types.List   `tfsdk:"name__n"`
	Name_Nic           types.List   `tfsdk:"name__nic"`
	Name_Nie           types.List   `tfsdk:"name__nie"`
	Name_Niew          types.List   `tfsdk:"name__niew"`
	Name_Nisw          types.List   `tfsdk:"name__nisw"`
	Name_Regex         types.List   `tfsdk:"name__regex"`
	Offset             types.Int64  `tfsdk:"offset"`
	Ordering           types.String `tfsdk:"ordering"`
	PeerGroup          types.List   `tfsdk:"peer_group"`
	PeerGroup_N        types.List   `tfsdk:"peer_group__n"`
	Q                  types.String `tfsdk:"q"`
	RemoteAddress      types.List   `tfsdk:"remote_address"`
	RemoteAddress_N    types.List   `tfsdk:"remote_address__n"`
	RemoteAddressId    types.List   `tfsdk:"remote_address_id"`
	RemoteAddressId_N  types.List   `tfsdk:"remote_address_id__n"`
	RemoteAs           types.List   `tfsdk:"remote_as"`
	RemoteAs_N         types.List   `tfsdk:"remote_as__n"`
	RemoteAsId         types.List   `tfsdk:"remote_as_id"`
	RemoteAsId_N       types.List   `tfsdk:"remote_as_id__n"`
	Results            types.List   `tfsdk:"results"`
	Site               types.List   `tfsdk:"site"`
	Site_N             types.List   `tfsdk:"site__n"`
	SiteId             types.List   `tfsdk:"site_id"`
	SiteId_N           types.List   `tfsdk:"site_id__n"`
	Status             types.String `tfsdk:"status"`
	Tag                types.List   `tfsdk:"tag"`
	Tag_N              types.List   `tfsdk:"tag__n"`
	TagId              types.List   `tfsdk:"tag_id"`
	TagId_N            types.List   `tfsdk:"tag_id__n"`
	Tenant             types.List   `tfsdk:"tenant"`
	Tenant_N           types.List   `tfsdk:"tenant__n"`
	TenantGroup        types.List   `tfsdk:"tenant_group"`
	TenantGroup_N      types.List   `tfsdk:"tenant_group__n"`
	TenantGroupId      types.List   `tfsdk:"tenant_group_id"`
	TenantGroupId_N    types.List   `tfsdk:"tenant_group_id__n"`
	TenantId           types.List   `tfsdk:"tenant_id"`
	TenantId_N         types.List   `tfsdk:"tenant_id__n"`
	UpdatedByRequest   types.String `tfsdk:"updated_by_request"`
	Virtualmachine     types.List   `tfsdk:"virtualmachine"`
	Virtualmachine_N   types.List   `tfsdk:"virtualmachine__n"`
	VirtualmachineId   types.List   `tfsdk:"virtualmachine_id"`
	VirtualmachineId_N types.List   `tfsdk:"virtualmachine_id__n"`
}

var _ basetypes.ObjectTypable = ResultsType{}

type ResultsType struct {
	basetypes.ObjectType
}

func (t ResultsType) Equal(o attr.Type) bool {
	other, ok := o.(ResultsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ResultsType) String() string {
	return "ResultsType"
}

func (t ResultsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	commentsAttribute, ok := attributes["comments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`comments is missing from object`)

		return nil, diags
	}

	commentsVal, ok := commentsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`comments expected to be basetypes.StringValue, was: %T`, commentsAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	deviceAttribute, ok := attributes["device"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device is missing from object`)

		return nil, diags
	}

	deviceVal, ok := deviceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device expected to be basetypes.ObjectValue, was: %T`, deviceAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	exportPoliciesAttribute, ok := attributes["export_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policies is missing from object`)

		return nil, diags
	}

	exportPoliciesVal, ok := exportPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policies expected to be basetypes.ListValue, was: %T`, exportPoliciesAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	importPoliciesAttribute, ok := attributes["import_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policies is missing from object`)

		return nil, diags
	}

	importPoliciesVal, ok := importPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policies expected to be basetypes.ListValue, was: %T`, importPoliciesAttribute))
	}

	lastUpdatedAttribute, ok := attributes["last_updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_updated is missing from object`)

		return nil, diags
	}

	lastUpdatedVal, ok := lastUpdatedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_updated expected to be basetypes.StringValue, was: %T`, lastUpdatedAttribute))
	}

	localAddressAttribute, ok := attributes["local_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_address is missing from object`)

		return nil, diags
	}

	localAddressVal, ok := localAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_address expected to be basetypes.ObjectValue, was: %T`, localAddressAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return nil, diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.ObjectValue, was: %T`, localAsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	peerGroupAttribute, ok := attributes["peer_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_group is missing from object`)

		return nil, diags
	}

	peerGroupVal, ok := peerGroupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_group expected to be basetypes.ObjectValue, was: %T`, peerGroupAttribute))
	}

	prefixListInAttribute, ok := attributes["prefix_list_in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_list_in is missing from object`)

		return nil, diags
	}

	prefixListInVal, ok := prefixListInAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_list_in expected to be basetypes.ObjectValue, was: %T`, prefixListInAttribute))
	}

	prefixListOutAttribute, ok := attributes["prefix_list_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_list_out is missing from object`)

		return nil, diags
	}

	prefixListOutVal, ok := prefixListOutAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_list_out expected to be basetypes.ObjectValue, was: %T`, prefixListOutAttribute))
	}

	remoteAddressAttribute, ok := attributes["remote_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_address is missing from object`)

		return nil, diags
	}

	remoteAddressVal, ok := remoteAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_address expected to be basetypes.ObjectValue, was: %T`, remoteAddressAttribute))
	}

	remoteAsAttribute, ok := attributes["remote_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_as is missing from object`)

		return nil, diags
	}

	remoteAsVal, ok := remoteAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_as expected to be basetypes.ObjectValue, was: %T`, remoteAsAttribute))
	}

	siteAttribute, ok := attributes["site"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site is missing from object`)

		return nil, diags
	}

	siteVal, ok := siteAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site expected to be basetypes.ObjectValue, was: %T`, siteAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return nil, diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.ObjectValue, was: %T`, tenantAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	virtualmachineAttribute, ok := attributes["virtualmachine"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`virtualmachine is missing from object`)

		return nil, diags
	}

	virtualmachineVal, ok := virtualmachineAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`virtualmachine expected to be basetypes.ObjectValue, was: %T`, virtualmachineAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ResultsValue{
		Comments:       commentsVal,
		Created:        createdVal,
		Description:    descriptionVal,
		Device:         deviceVal,
		Display:        displayVal,
		ExportPolicies: exportPoliciesVal,
		Id:             idVal,
		ImportPolicies: importPoliciesVal,
		LastUpdated:    lastUpdatedVal,
		LocalAddress:   localAddressVal,
		LocalAs:        localAsVal,
		Name:           nameVal,
		PeerGroup:      peerGroupVal,
		PrefixListIn:   prefixListInVal,
		PrefixListOut:  prefixListOutVal,
		RemoteAddress:  remoteAddressVal,
		RemoteAs:       remoteAsVal,
		Site:           siteVal,
		Status:         statusVal,
		Tags:           tagsVal,
		Tenant:         tenantVal,
		Url:            urlVal,
		Virtualmachine: virtualmachineVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewResultsValueNull() ResultsValue {
	return ResultsValue{
		state: attr.ValueStateNull,
	}
}

func NewResultsValueUnknown() ResultsValue {
	return ResultsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewResultsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ResultsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ResultsValue Attribute Value",
				"While creating a ResultsValue value, a missing attribute value was detected. "+
					"A ResultsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResultsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ResultsValue Attribute Type",
				"While creating a ResultsValue value, an invalid attribute value was detected. "+
					"A ResultsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResultsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ResultsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ResultsValue Attribute Value",
				"While creating a ResultsValue value, an extra attribute value was detected. "+
					"A ResultsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ResultsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewResultsValueUnknown(), diags
	}

	commentsAttribute, ok := attributes["comments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`comments is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	commentsVal, ok := commentsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`comments expected to be basetypes.StringValue, was: %T`, commentsAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	deviceAttribute, ok := attributes["device"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	deviceVal, ok := deviceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device expected to be basetypes.ObjectValue, was: %T`, deviceAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	exportPoliciesAttribute, ok := attributes["export_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policies is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	exportPoliciesVal, ok := exportPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policies expected to be basetypes.ListValue, was: %T`, exportPoliciesAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	importPoliciesAttribute, ok := attributes["import_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policies is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	importPoliciesVal, ok := importPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policies expected to be basetypes.ListValue, was: %T`, importPoliciesAttribute))
	}

	lastUpdatedAttribute, ok := attributes["last_updated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_updated is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	lastUpdatedVal, ok := lastUpdatedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_updated expected to be basetypes.StringValue, was: %T`, lastUpdatedAttribute))
	}

	localAddressAttribute, ok := attributes["local_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_address is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	localAddressVal, ok := localAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_address expected to be basetypes.ObjectValue, was: %T`, localAddressAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.ObjectValue, was: %T`, localAsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	peerGroupAttribute, ok := attributes["peer_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_group is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	peerGroupVal, ok := peerGroupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_group expected to be basetypes.ObjectValue, was: %T`, peerGroupAttribute))
	}

	prefixListInAttribute, ok := attributes["prefix_list_in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_list_in is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	prefixListInVal, ok := prefixListInAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_list_in expected to be basetypes.ObjectValue, was: %T`, prefixListInAttribute))
	}

	prefixListOutAttribute, ok := attributes["prefix_list_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_list_out is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	prefixListOutVal, ok := prefixListOutAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_list_out expected to be basetypes.ObjectValue, was: %T`, prefixListOutAttribute))
	}

	remoteAddressAttribute, ok := attributes["remote_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_address is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	remoteAddressVal, ok := remoteAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_address expected to be basetypes.ObjectValue, was: %T`, remoteAddressAttribute))
	}

	remoteAsAttribute, ok := attributes["remote_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_as is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	remoteAsVal, ok := remoteAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_as expected to be basetypes.ObjectValue, was: %T`, remoteAsAttribute))
	}

	siteAttribute, ok := attributes["site"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	siteVal, ok := siteAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site expected to be basetypes.ObjectValue, was: %T`, siteAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.ObjectValue, was: %T`, tenantAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	virtualmachineAttribute, ok := attributes["virtualmachine"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`virtualmachine is missing from object`)

		return NewResultsValueUnknown(), diags
	}

	virtualmachineVal, ok := virtualmachineAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`virtualmachine expected to be basetypes.ObjectValue, was: %T`, virtualmachineAttribute))
	}

	if diags.HasError() {
		return NewResultsValueUnknown(), diags
	}

	return ResultsValue{
		Comments:       commentsVal,
		Created:        createdVal,
		Description:    descriptionVal,
		Device:         deviceVal,
		Display:        displayVal,
		ExportPolicies: exportPoliciesVal,
		Id:             idVal,
		ImportPolicies: importPoliciesVal,
		LastUpdated:    lastUpdatedVal,
		LocalAddress:   localAddressVal,
		LocalAs:        localAsVal,
		Name:           nameVal,
		PeerGroup:      peerGroupVal,
		PrefixListIn:   prefixListInVal,
		PrefixListOut:  prefixListOutVal,
		RemoteAddress:  remoteAddressVal,
		RemoteAs:       remoteAsVal,
		Site:           siteVal,
		Status:         statusVal,
		Tags:           tagsVal,
		Tenant:         tenantVal,
		Url:            urlVal,
		Virtualmachine: virtualmachineVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewResultsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ResultsValue {
	object, diags := NewResultsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewResultsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ResultsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewResultsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewResultsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewResultsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewResultsValueMust(ResultsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ResultsType) ValueType(ctx context.Context) attr.Value {
	return ResultsValue{}
}

var _ basetypes.ObjectValuable = ResultsValue{}

type ResultsValue struct {
	Comments       basetypes.StringValue `tfsdk:"comments"`
	Created        basetypes.StringValue `tfsdk:"created"`
	Description    basetypes.StringValue `tfsdk:"description"`
	Device         basetypes.ObjectValue `tfsdk:"device"`
	Display        basetypes.StringValue `tfsdk:"display"`
	ExportPolicies basetypes.ListValue   `tfsdk:"export_policies"`
	Id             basetypes.Int64Value  `tfsdk:"id"`
	ImportPolicies basetypes.ListValue   `tfsdk:"import_policies"`
	LastUpdated    basetypes.StringValue `tfsdk:"last_updated"`
	LocalAddress   basetypes.ObjectValue `tfsdk:"local_address"`
	LocalAs        basetypes.ObjectValue `tfsdk:"local_as"`
	Name           basetypes.StringValue `tfsdk:"name"`
	PeerGroup      basetypes.ObjectValue `tfsdk:"peer_group"`
	PrefixListIn   basetypes.ObjectValue `tfsdk:"prefix_list_in"`
	PrefixListOut  basetypes.ObjectValue `tfsdk:"prefix_list_out"`
	RemoteAddress  basetypes.ObjectValue `tfsdk:"remote_address"`
	RemoteAs       basetypes.ObjectValue `tfsdk:"remote_as"`
	Site           basetypes.ObjectValue `tfsdk:"site"`
	Status         basetypes.ObjectValue `tfsdk:"status"`
	Tags           basetypes.ListValue   `tfsdk:"tags"`
	Tenant         basetypes.ObjectValue `tfsdk:"tenant"`
	Url            basetypes.StringValue `tfsdk:"url"`
	Virtualmachine basetypes.ObjectValue `tfsdk:"virtualmachine"`
	state          attr.ValueState
}

func (v ResultsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 23)

	var val tftypes.Value
	var err error

	attrTypes["comments"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["device"] = basetypes.ObjectType{
		AttrTypes: DeviceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["export_policies"] = basetypes.ListType{
		ElemType: ExportPoliciesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["import_policies"] = basetypes.ListType{
		ElemType: ImportPoliciesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["last_updated"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_address"] = basetypes.ObjectType{
		AttrTypes: LocalAddressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["local_as"] = basetypes.ObjectType{
		AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["peer_group"] = basetypes.ObjectType{
		AttrTypes: PeerGroupValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_list_in"] = basetypes.ObjectType{
		AttrTypes: PrefixListInValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_list_out"] = basetypes.ObjectType{
		AttrTypes: PrefixListOutValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["remote_address"] = basetypes.ObjectType{
		AttrTypes: RemoteAddressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["remote_as"] = basetypes.ObjectType{
		AttrTypes: RemoteAsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["site"] = basetypes.ObjectType{
		AttrTypes: SiteValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.ObjectType{
		AttrTypes: StatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tenant"] = basetypes.ObjectType{
		AttrTypes: TenantValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["virtualmachine"] = basetypes.ObjectType{
		AttrTypes: VirtualmachineValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 23)

		val, err = v.Comments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["comments"] = val

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Device.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.ExportPolicies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policies"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.ImportPolicies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policies"] = val

		val, err = v.LastUpdated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_updated"] = val

		val, err = v.LocalAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_address"] = val

		val, err = v.LocalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_as"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PeerGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_group"] = val

		val, err = v.PrefixListIn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_list_in"] = val

		val, err = v.PrefixListOut.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_list_out"] = val

		val, err = v.RemoteAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_address"] = val

		val, err = v.RemoteAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_as"] = val

		val, err = v.Site.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["site"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.Tenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Virtualmachine.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["virtualmachine"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ResultsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ResultsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ResultsValue) String() string {
	return "ResultsValue"
}

func (v ResultsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var device basetypes.ObjectValue

	if v.Device.IsNull() {
		device = types.ObjectNull(
			DeviceValue{}.AttributeTypes(ctx),
		)
	}

	if v.Device.IsUnknown() {
		device = types.ObjectUnknown(
			DeviceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Device.IsNull() && !v.Device.IsUnknown() {
		device = types.ObjectValueMust(
			DeviceValue{}.AttributeTypes(ctx),
			v.Device.Attributes(),
		)
	}

	exportPolicies := types.ListValueMust(
		ExportPoliciesType{
			basetypes.ObjectType{
				AttrTypes: ExportPoliciesValue{}.AttributeTypes(ctx),
			},
		},
		v.ExportPolicies.Elements(),
	)

	if v.ExportPolicies.IsNull() {
		exportPolicies = types.ListNull(
			ExportPoliciesType{
				basetypes.ObjectType{
					AttrTypes: ExportPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ExportPolicies.IsUnknown() {
		exportPolicies = types.ListUnknown(
			ExportPoliciesType{
				basetypes.ObjectType{
					AttrTypes: ExportPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	importPolicies := types.ListValueMust(
		ImportPoliciesType{
			basetypes.ObjectType{
				AttrTypes: ImportPoliciesValue{}.AttributeTypes(ctx),
			},
		},
		v.ImportPolicies.Elements(),
	)

	if v.ImportPolicies.IsNull() {
		importPolicies = types.ListNull(
			ImportPoliciesType{
				basetypes.ObjectType{
					AttrTypes: ImportPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ImportPolicies.IsUnknown() {
		importPolicies = types.ListUnknown(
			ImportPoliciesType{
				basetypes.ObjectType{
					AttrTypes: ImportPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var localAddress basetypes.ObjectValue

	if v.LocalAddress.IsNull() {
		localAddress = types.ObjectNull(
			LocalAddressValue{}.AttributeTypes(ctx),
		)
	}

	if v.LocalAddress.IsUnknown() {
		localAddress = types.ObjectUnknown(
			LocalAddressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LocalAddress.IsNull() && !v.LocalAddress.IsUnknown() {
		localAddress = types.ObjectValueMust(
			LocalAddressValue{}.AttributeTypes(ctx),
			v.LocalAddress.Attributes(),
		)
	}

	var localAs basetypes.ObjectValue

	if v.LocalAs.IsNull() {
		localAs = types.ObjectNull(
			LocalAsValue{}.AttributeTypes(ctx),
		)
	}

	if v.LocalAs.IsUnknown() {
		localAs = types.ObjectUnknown(
			LocalAsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LocalAs.IsNull() && !v.LocalAs.IsUnknown() {
		localAs = types.ObjectValueMust(
			LocalAsValue{}.AttributeTypes(ctx),
			v.LocalAs.Attributes(),
		)
	}

	var peerGroup basetypes.ObjectValue

	if v.PeerGroup.IsNull() {
		peerGroup = types.ObjectNull(
			PeerGroupValue{}.AttributeTypes(ctx),
		)
	}

	if v.PeerGroup.IsUnknown() {
		peerGroup = types.ObjectUnknown(
			PeerGroupValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PeerGroup.IsNull() && !v.PeerGroup.IsUnknown() {
		peerGroup = types.ObjectValueMust(
			PeerGroupValue{}.AttributeTypes(ctx),
			v.PeerGroup.Attributes(),
		)
	}

	var prefixListIn basetypes.ObjectValue

	if v.PrefixListIn.IsNull() {
		prefixListIn = types.ObjectNull(
			PrefixListInValue{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixListIn.IsUnknown() {
		prefixListIn = types.ObjectUnknown(
			PrefixListInValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixListIn.IsNull() && !v.PrefixListIn.IsUnknown() {
		prefixListIn = types.ObjectValueMust(
			PrefixListInValue{}.AttributeTypes(ctx),
			v.PrefixListIn.Attributes(),
		)
	}

	var prefixListOut basetypes.ObjectValue

	if v.PrefixListOut.IsNull() {
		prefixListOut = types.ObjectNull(
			PrefixListOutValue{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixListOut.IsUnknown() {
		prefixListOut = types.ObjectUnknown(
			PrefixListOutValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixListOut.IsNull() && !v.PrefixListOut.IsUnknown() {
		prefixListOut = types.ObjectValueMust(
			PrefixListOutValue{}.AttributeTypes(ctx),
			v.PrefixListOut.Attributes(),
		)
	}

	var remoteAddress basetypes.ObjectValue

	if v.RemoteAddress.IsNull() {
		remoteAddress = types.ObjectNull(
			RemoteAddressValue{}.AttributeTypes(ctx),
		)
	}

	if v.RemoteAddress.IsUnknown() {
		remoteAddress = types.ObjectUnknown(
			RemoteAddressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RemoteAddress.IsNull() && !v.RemoteAddress.IsUnknown() {
		remoteAddress = types.ObjectValueMust(
			RemoteAddressValue{}.AttributeTypes(ctx),
			v.RemoteAddress.Attributes(),
		)
	}

	var remoteAs basetypes.ObjectValue

	if v.RemoteAs.IsNull() {
		remoteAs = types.ObjectNull(
			RemoteAsValue{}.AttributeTypes(ctx),
		)
	}

	if v.RemoteAs.IsUnknown() {
		remoteAs = types.ObjectUnknown(
			RemoteAsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RemoteAs.IsNull() && !v.RemoteAs.IsUnknown() {
		remoteAs = types.ObjectValueMust(
			RemoteAsValue{}.AttributeTypes(ctx),
			v.RemoteAs.Attributes(),
		)
	}

	var site basetypes.ObjectValue

	if v.Site.IsNull() {
		site = types.ObjectNull(
			SiteValue{}.AttributeTypes(ctx),
		)
	}

	if v.Site.IsUnknown() {
		site = types.ObjectUnknown(
			SiteValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Site.IsNull() && !v.Site.IsUnknown() {
		site = types.ObjectValueMust(
			SiteValue{}.AttributeTypes(ctx),
			v.Site.Attributes(),
		)
	}

	var status basetypes.ObjectValue

	if v.Status.IsNull() {
		status = types.ObjectNull(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if v.Status.IsUnknown() {
		status = types.ObjectUnknown(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Status.IsNull() && !v.Status.IsUnknown() {
		status = types.ObjectValueMust(
			StatusValue{}.AttributeTypes(ctx),
			v.Status.Attributes(),
		)
	}

	var tenant basetypes.ObjectValue

	if v.Tenant.IsNull() {
		tenant = types.ObjectNull(
			TenantValue{}.AttributeTypes(ctx),
		)
	}

	if v.Tenant.IsUnknown() {
		tenant = types.ObjectUnknown(
			TenantValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Tenant.IsNull() && !v.Tenant.IsUnknown() {
		tenant = types.ObjectValueMust(
			TenantValue{}.AttributeTypes(ctx),
			v.Tenant.Attributes(),
		)
	}

	var virtualmachine basetypes.ObjectValue

	if v.Virtualmachine.IsNull() {
		virtualmachine = types.ObjectNull(
			VirtualmachineValue{}.AttributeTypes(ctx),
		)
	}

	if v.Virtualmachine.IsUnknown() {
		virtualmachine = types.ObjectUnknown(
			VirtualmachineValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Virtualmachine.IsNull() && !v.Virtualmachine.IsUnknown() {
		virtualmachine = types.ObjectValueMust(
			VirtualmachineValue{}.AttributeTypes(ctx),
			v.Virtualmachine.Attributes(),
		)
	}

	var tagsVal basetypes.ListValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.ListUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.ListValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"comments":    basetypes.StringType{},
			"created":     basetypes.StringType{},
			"description": basetypes.StringType{},
			"device": basetypes.ObjectType{
				AttrTypes: DeviceValue{}.AttributeTypes(ctx),
			},
			"display": basetypes.StringType{},
			"export_policies": basetypes.ListType{
				ElemType: ExportPoliciesValue{}.Type(ctx),
			},
			"id": basetypes.Int64Type{},
			"import_policies": basetypes.ListType{
				ElemType: ImportPoliciesValue{}.Type(ctx),
			},
			"last_updated": basetypes.StringType{},
			"local_address": basetypes.ObjectType{
				AttrTypes: LocalAddressValue{}.AttributeTypes(ctx),
			},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
			},
			"name": basetypes.StringType{},
			"peer_group": basetypes.ObjectType{
				AttrTypes: PeerGroupValue{}.AttributeTypes(ctx),
			},
			"prefix_list_in": basetypes.ObjectType{
				AttrTypes: PrefixListInValue{}.AttributeTypes(ctx),
			},
			"prefix_list_out": basetypes.ObjectType{
				AttrTypes: PrefixListOutValue{}.AttributeTypes(ctx),
			},
			"remote_address": basetypes.ObjectType{
				AttrTypes: RemoteAddressValue{}.AttributeTypes(ctx),
			},
			"remote_as": basetypes.ObjectType{
				AttrTypes: RemoteAsValue{}.AttributeTypes(ctx),
			},
			"site": basetypes.ObjectType{
				AttrTypes: SiteValue{}.AttributeTypes(ctx),
			},
			"status": basetypes.ObjectType{
				AttrTypes: StatusValue{}.AttributeTypes(ctx),
			},
			"tags": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tenant": basetypes.ObjectType{
				AttrTypes: TenantValue{}.AttributeTypes(ctx),
			},
			"url": basetypes.StringType{},
			"virtualmachine": basetypes.ObjectType{
				AttrTypes: VirtualmachineValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"comments":    basetypes.StringType{},
		"created":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"device": basetypes.ObjectType{
			AttrTypes: DeviceValue{}.AttributeTypes(ctx),
		},
		"display": basetypes.StringType{},
		"export_policies": basetypes.ListType{
			ElemType: ExportPoliciesValue{}.Type(ctx),
		},
		"id": basetypes.Int64Type{},
		"import_policies": basetypes.ListType{
			ElemType: ImportPoliciesValue{}.Type(ctx),
		},
		"last_updated": basetypes.StringType{},
		"local_address": basetypes.ObjectType{
			AttrTypes: LocalAddressValue{}.AttributeTypes(ctx),
		},
		"local_as": basetypes.ObjectType{
			AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
		"peer_group": basetypes.ObjectType{
			AttrTypes: PeerGroupValue{}.AttributeTypes(ctx),
		},
		"prefix_list_in": basetypes.ObjectType{
			AttrTypes: PrefixListInValue{}.AttributeTypes(ctx),
		},
		"prefix_list_out": basetypes.ObjectType{
			AttrTypes: PrefixListOutValue{}.AttributeTypes(ctx),
		},
		"remote_address": basetypes.ObjectType{
			AttrTypes: RemoteAddressValue{}.AttributeTypes(ctx),
		},
		"remote_as": basetypes.ObjectType{
			AttrTypes: RemoteAsValue{}.AttributeTypes(ctx),
		},
		"site": basetypes.ObjectType{
			AttrTypes: SiteValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
		"tenant": basetypes.ObjectType{
			AttrTypes: TenantValue{}.AttributeTypes(ctx),
		},
		"url": basetypes.StringType{},
		"virtualmachine": basetypes.ObjectType{
			AttrTypes: VirtualmachineValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"comments":        v.Comments,
			"created":         v.Created,
			"description":     v.Description,
			"device":          device,
			"display":         v.Display,
			"export_policies": exportPolicies,
			"id":              v.Id,
			"import_policies": importPolicies,
			"last_updated":    v.LastUpdated,
			"local_address":   localAddress,
			"local_as":        localAs,
			"name":            v.Name,
			"peer_group":      peerGroup,
			"prefix_list_in":  prefixListIn,
			"prefix_list_out": prefixListOut,
			"remote_address":  remoteAddress,
			"remote_as":       remoteAs,
			"site":            site,
			"status":          status,
			"tags":            tagsVal,
			"tenant":          tenant,
			"url":             v.Url,
			"virtualmachine":  virtualmachine,
		})

	return objVal, diags
}

func (v ResultsValue) Equal(o attr.Value) bool {
	other, ok := o.(ResultsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Comments.Equal(other.Comments) {
		return false
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Device.Equal(other.Device) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.ExportPolicies.Equal(other.ExportPolicies) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.ImportPolicies.Equal(other.ImportPolicies) {
		return false
	}

	if !v.LastUpdated.Equal(other.LastUpdated) {
		return false
	}

	if !v.LocalAddress.Equal(other.LocalAddress) {
		return false
	}

	if !v.LocalAs.Equal(other.LocalAs) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PeerGroup.Equal(other.PeerGroup) {
		return false
	}

	if !v.PrefixListIn.Equal(other.PrefixListIn) {
		return false
	}

	if !v.PrefixListOut.Equal(other.PrefixListOut) {
		return false
	}

	if !v.RemoteAddress.Equal(other.RemoteAddress) {
		return false
	}

	if !v.RemoteAs.Equal(other.RemoteAs) {
		return false
	}

	if !v.Site.Equal(other.Site) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.Tenant.Equal(other.Tenant) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Virtualmachine.Equal(other.Virtualmachine) {
		return false
	}

	return true
}

func (v ResultsValue) Type(ctx context.Context) attr.Type {
	return ResultsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ResultsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"comments":    basetypes.StringType{},
		"created":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"device": basetypes.ObjectType{
			AttrTypes: DeviceValue{}.AttributeTypes(ctx),
		},
		"display": basetypes.StringType{},
		"export_policies": basetypes.ListType{
			ElemType: ExportPoliciesValue{}.Type(ctx),
		},
		"id": basetypes.Int64Type{},
		"import_policies": basetypes.ListType{
			ElemType: ImportPoliciesValue{}.Type(ctx),
		},
		"last_updated": basetypes.StringType{},
		"local_address": basetypes.ObjectType{
			AttrTypes: LocalAddressValue{}.AttributeTypes(ctx),
		},
		"local_as": basetypes.ObjectType{
			AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
		"peer_group": basetypes.ObjectType{
			AttrTypes: PeerGroupValue{}.AttributeTypes(ctx),
		},
		"prefix_list_in": basetypes.ObjectType{
			AttrTypes: PrefixListInValue{}.AttributeTypes(ctx),
		},
		"prefix_list_out": basetypes.ObjectType{
			AttrTypes: PrefixListOutValue{}.AttributeTypes(ctx),
		},
		"remote_address": basetypes.ObjectType{
			AttrTypes: RemoteAddressValue{}.AttributeTypes(ctx),
		},
		"remote_as": basetypes.ObjectType{
			AttrTypes: RemoteAsValue{}.AttributeTypes(ctx),
		},
		"site": basetypes.ObjectType{
			AttrTypes: SiteValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
		"tenant": basetypes.ObjectType{
			AttrTypes: TenantValue{}.AttributeTypes(ctx),
		},
		"url": basetypes.StringType{},
		"virtualmachine": basetypes.ObjectType{
			AttrTypes: VirtualmachineValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DeviceType{}

type DeviceType struct {
	basetypes.ObjectType
}

func (t DeviceType) Equal(o attr.Type) bool {
	other, ok := o.(DeviceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviceType) String() string {
	return "DeviceType"
}

func (t DeviceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviceValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDeviceValueNull() DeviceValue {
	return DeviceValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviceValueUnknown() DeviceValue {
	return DeviceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviceValue Attribute Value",
				"While creating a DeviceValue value, a missing attribute value was detected. "+
					"A DeviceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviceValue Attribute Type",
				"While creating a DeviceValue value, an invalid attribute value was detected. "+
					"A DeviceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviceValue Attribute Value",
				"While creating a DeviceValue value, an extra attribute value was detected. "+
					"A DeviceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviceValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewDeviceValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewDeviceValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDeviceValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDeviceValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewDeviceValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewDeviceValueUnknown(), diags
	}

	return DeviceValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDeviceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviceValue {
	object, diags := NewDeviceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviceValueMust(DeviceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviceType) ValueType(ctx context.Context) attr.Value {
	return DeviceValue{}
}

var _ basetypes.ObjectValuable = DeviceValue{}

type DeviceValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v DeviceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviceValue) String() string {
	return "DeviceValue"
}

func (v DeviceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v DeviceValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v DeviceValue) Type(ctx context.Context) attr.Type {
	return DeviceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ExportPoliciesType{}

type ExportPoliciesType struct {
	basetypes.ObjectType
}

func (t ExportPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(ExportPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExportPoliciesType) String() string {
	return "ExportPoliciesType"
}

func (t ExportPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	commentsAttribute, ok := attributes["comments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`comments is missing from object`)

		return nil, diags
	}

	commentsVal, ok := commentsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`comments expected to be basetypes.StringValue, was: %T`, commentsAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExportPoliciesValue{
		Comments:    commentsVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Tags:        tagsVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewExportPoliciesValueNull() ExportPoliciesValue {
	return ExportPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewExportPoliciesValueUnknown() ExportPoliciesValue {
	return ExportPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExportPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExportPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExportPoliciesValue Attribute Value",
				"While creating a ExportPoliciesValue value, a missing attribute value was detected. "+
					"A ExportPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExportPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExportPoliciesValue Attribute Type",
				"While creating a ExportPoliciesValue value, an invalid attribute value was detected. "+
					"A ExportPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExportPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExportPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExportPoliciesValue Attribute Value",
				"While creating a ExportPoliciesValue value, an extra attribute value was detected. "+
					"A ExportPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExportPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExportPoliciesValueUnknown(), diags
	}

	commentsAttribute, ok := attributes["comments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`comments is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	commentsVal, ok := commentsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`comments expected to be basetypes.StringValue, was: %T`, commentsAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewExportPoliciesValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewExportPoliciesValueUnknown(), diags
	}

	return ExportPoliciesValue{
		Comments:    commentsVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Tags:        tagsVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewExportPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExportPoliciesValue {
	object, diags := NewExportPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExportPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExportPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExportPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExportPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExportPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExportPoliciesValueMust(ExportPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExportPoliciesType) ValueType(ctx context.Context) attr.Value {
	return ExportPoliciesValue{}
}

var _ basetypes.ObjectValuable = ExportPoliciesValue{}

type ExportPoliciesValue struct {
	Comments    basetypes.StringValue `tfsdk:"comments"`
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Tags        basetypes.ListValue   `tfsdk:"tags"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v ExportPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["comments"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Comments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["comments"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExportPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExportPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExportPoliciesValue) String() string {
	return "ExportPoliciesValue"
}

func (v ExportPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var tagsVal basetypes.ListValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.ListUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.ListValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"comments":    basetypes.StringType{},
			"description": basetypes.StringType{},
			"display":     basetypes.StringType{},
			"id":          basetypes.Int64Type{},
			"name":        basetypes.StringType{},
			"tags": basetypes.ListType{
				ElemType: types.StringType,
			},
			"url": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"comments":    basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
		"url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"comments":    v.Comments,
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"tags":        tagsVal,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v ExportPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(ExportPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Comments.Equal(other.Comments) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v ExportPoliciesValue) Type(ctx context.Context) attr.Type {
	return ExportPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExportPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"comments":    basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
		"url": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ImportPoliciesType{}

type ImportPoliciesType struct {
	basetypes.ObjectType
}

func (t ImportPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(ImportPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ImportPoliciesType) String() string {
	return "ImportPoliciesType"
}

func (t ImportPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	commentsAttribute, ok := attributes["comments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`comments is missing from object`)

		return nil, diags
	}

	commentsVal, ok := commentsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`comments expected to be basetypes.StringValue, was: %T`, commentsAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ImportPoliciesValue{
		Comments:    commentsVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Tags:        tagsVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewImportPoliciesValueNull() ImportPoliciesValue {
	return ImportPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewImportPoliciesValueUnknown() ImportPoliciesValue {
	return ImportPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewImportPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ImportPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ImportPoliciesValue Attribute Value",
				"While creating a ImportPoliciesValue value, a missing attribute value was detected. "+
					"A ImportPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImportPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ImportPoliciesValue Attribute Type",
				"While creating a ImportPoliciesValue value, an invalid attribute value was detected. "+
					"A ImportPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImportPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ImportPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ImportPoliciesValue Attribute Value",
				"While creating a ImportPoliciesValue value, an extra attribute value was detected. "+
					"A ImportPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ImportPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewImportPoliciesValueUnknown(), diags
	}

	commentsAttribute, ok := attributes["comments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`comments is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	commentsVal, ok := commentsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`comments expected to be basetypes.StringValue, was: %T`, commentsAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewImportPoliciesValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewImportPoliciesValueUnknown(), diags
	}

	return ImportPoliciesValue{
		Comments:    commentsVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Tags:        tagsVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewImportPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ImportPoliciesValue {
	object, diags := NewImportPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewImportPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ImportPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewImportPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewImportPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewImportPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewImportPoliciesValueMust(ImportPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ImportPoliciesType) ValueType(ctx context.Context) attr.Value {
	return ImportPoliciesValue{}
}

var _ basetypes.ObjectValuable = ImportPoliciesValue{}

type ImportPoliciesValue struct {
	Comments    basetypes.StringValue `tfsdk:"comments"`
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Tags        basetypes.ListValue   `tfsdk:"tags"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v ImportPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["comments"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Comments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["comments"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ImportPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ImportPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ImportPoliciesValue) String() string {
	return "ImportPoliciesValue"
}

func (v ImportPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var tagsVal basetypes.ListValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.ListUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.ListValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"comments":    basetypes.StringType{},
			"description": basetypes.StringType{},
			"display":     basetypes.StringType{},
			"id":          basetypes.Int64Type{},
			"name":        basetypes.StringType{},
			"tags": basetypes.ListType{
				ElemType: types.StringType,
			},
			"url": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"comments":    basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
		"url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"comments":    v.Comments,
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"tags":        tagsVal,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v ImportPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(ImportPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Comments.Equal(other.Comments) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v ImportPoliciesValue) Type(ctx context.Context) attr.Type {
	return ImportPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ImportPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"comments":    basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
		"url": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LocalAddressType{}

type LocalAddressType struct {
	basetypes.ObjectType
}

func (t LocalAddressType) Equal(o attr.Type) bool {
	other, ok := o.(LocalAddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalAddressType) String() string {
	return "LocalAddressType"
}

func (t LocalAddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	familyAttribute, ok := attributes["family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family is missing from object`)

		return nil, diags
	}

	familyVal, ok := familyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family expected to be basetypes.Int64Value, was: %T`, familyAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalAddressValue{
		Address:     addressVal,
		Description: descriptionVal,
		Display:     displayVal,
		Family:      familyVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLocalAddressValueNull() LocalAddressValue {
	return LocalAddressValue{
		state: attr.ValueStateNull,
	}
}

func NewLocalAddressValueUnknown() LocalAddressValue {
	return LocalAddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalAddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalAddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalAddressValue Attribute Value",
				"While creating a LocalAddressValue value, a missing attribute value was detected. "+
					"A LocalAddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalAddressValue Attribute Type",
				"While creating a LocalAddressValue value, an invalid attribute value was detected. "+
					"A LocalAddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalAddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalAddressValue Attribute Value",
				"While creating a LocalAddressValue value, an extra attribute value was detected. "+
					"A LocalAddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalAddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalAddressValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewLocalAddressValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewLocalAddressValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewLocalAddressValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	familyAttribute, ok := attributes["family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family is missing from object`)

		return NewLocalAddressValueUnknown(), diags
	}

	familyVal, ok := familyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family expected to be basetypes.Int64Value, was: %T`, familyAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewLocalAddressValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewLocalAddressValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewLocalAddressValueUnknown(), diags
	}

	return LocalAddressValue{
		Address:     addressVal,
		Description: descriptionVal,
		Display:     displayVal,
		Family:      familyVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLocalAddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalAddressValue {
	object, diags := NewLocalAddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalAddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalAddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalAddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalAddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalAddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalAddressValueMust(LocalAddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalAddressType) ValueType(ctx context.Context) attr.Value {
	return LocalAddressValue{}
}

var _ basetypes.ObjectValuable = LocalAddressValue{}

type LocalAddressValue struct {
	Address     basetypes.StringValue `tfsdk:"address"`
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Family      basetypes.Int64Value  `tfsdk:"family"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v LocalAddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["family"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Family.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["family"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalAddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalAddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalAddressValue) String() string {
	return "LocalAddressValue"
}

func (v LocalAddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"address":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"family":      basetypes.Int64Type{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address":     v.Address,
			"description": v.Description,
			"display":     v.Display,
			"family":      v.Family,
			"id":          v.Id,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v LocalAddressValue) Equal(o attr.Value) bool {
	other, ok := o.(LocalAddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Family.Equal(other.Family) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v LocalAddressValue) Type(ctx context.Context) attr.Type {
	return LocalAddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalAddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"family":      basetypes.Int64Type{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LocalAsType{}

type LocalAsType struct {
	basetypes.ObjectType
}

func (t LocalAsType) Equal(o attr.Type) bool {
	other, ok := o.(LocalAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalAsType) String() string {
	return "LocalAsType"
}

func (t LocalAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return nil, diags
	}

	asnVal, ok := asnAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.Int64Value, was: %T`, asnAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalAsValue{
		Asn:         asnVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLocalAsValueNull() LocalAsValue {
	return LocalAsValue{
		state: attr.ValueStateNull,
	}
}

func NewLocalAsValueUnknown() LocalAsValue {
	return LocalAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalAsValue Attribute Value",
				"While creating a LocalAsValue value, a missing attribute value was detected. "+
					"A LocalAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalAsValue Attribute Type",
				"While creating a LocalAsValue value, an invalid attribute value was detected. "+
					"A LocalAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalAsValue Attribute Value",
				"While creating a LocalAsValue value, an extra attribute value was detected. "+
					"A LocalAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalAsValueUnknown(), diags
	}

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	asnVal, ok := asnAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.Int64Value, was: %T`, asnAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewLocalAsValueUnknown(), diags
	}

	return LocalAsValue{
		Asn:         asnVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLocalAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalAsValue {
	object, diags := NewLocalAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalAsValueMust(LocalAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalAsType) ValueType(ctx context.Context) attr.Value {
	return LocalAsValue{}
}

var _ basetypes.ObjectValuable = LocalAsValue{}

type LocalAsValue struct {
	Asn         basetypes.Int64Value  `tfsdk:"asn"`
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v LocalAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["asn"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Asn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalAsValue) String() string {
	return "LocalAsValue"
}

func (v LocalAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"asn":         basetypes.Int64Type{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn":         v.Asn,
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v LocalAsValue) Equal(o attr.Value) bool {
	other, ok := o.(LocalAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Asn.Equal(other.Asn) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v LocalAsValue) Type(ctx context.Context) attr.Type {
	return LocalAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn":         basetypes.Int64Type{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PeerGroupType{}

type PeerGroupType struct {
	basetypes.ObjectType
}

func (t PeerGroupType) Equal(o attr.Type) bool {
	other, ok := o.(PeerGroupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PeerGroupType) String() string {
	return "PeerGroupType"
}

func (t PeerGroupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PeerGroupValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPeerGroupValueNull() PeerGroupValue {
	return PeerGroupValue{
		state: attr.ValueStateNull,
	}
}

func NewPeerGroupValueUnknown() PeerGroupValue {
	return PeerGroupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPeerGroupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PeerGroupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PeerGroupValue Attribute Value",
				"While creating a PeerGroupValue value, a missing attribute value was detected. "+
					"A PeerGroupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PeerGroupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PeerGroupValue Attribute Type",
				"While creating a PeerGroupValue value, an invalid attribute value was detected. "+
					"A PeerGroupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PeerGroupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PeerGroupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PeerGroupValue Attribute Value",
				"While creating a PeerGroupValue value, an extra attribute value was detected. "+
					"A PeerGroupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PeerGroupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPeerGroupValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPeerGroupValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewPeerGroupValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewPeerGroupValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPeerGroupValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewPeerGroupValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewPeerGroupValueUnknown(), diags
	}

	return PeerGroupValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPeerGroupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PeerGroupValue {
	object, diags := NewPeerGroupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPeerGroupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PeerGroupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPeerGroupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPeerGroupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPeerGroupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPeerGroupValueMust(PeerGroupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PeerGroupType) ValueType(ctx context.Context) attr.Value {
	return PeerGroupValue{}
}

var _ basetypes.ObjectValuable = PeerGroupValue{}

type PeerGroupValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v PeerGroupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PeerGroupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PeerGroupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PeerGroupValue) String() string {
	return "PeerGroupValue"
}

func (v PeerGroupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v PeerGroupValue) Equal(o attr.Value) bool {
	other, ok := o.(PeerGroupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v PeerGroupValue) Type(ctx context.Context) attr.Type {
	return PeerGroupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PeerGroupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PrefixListInType{}

type PrefixListInType struct {
	basetypes.ObjectType
}

func (t PrefixListInType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixListInType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixListInType) String() string {
	return "PrefixListInType"
}

func (t PrefixListInType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixListInValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrefixListInValueNull() PrefixListInValue {
	return PrefixListInValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixListInValueUnknown() PrefixListInValue {
	return PrefixListInValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixListInValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixListInValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixListInValue Attribute Value",
				"While creating a PrefixListInValue value, a missing attribute value was detected. "+
					"A PrefixListInValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixListInValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixListInValue Attribute Type",
				"While creating a PrefixListInValue value, an invalid attribute value was detected. "+
					"A PrefixListInValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixListInValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixListInValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixListInValue Attribute Value",
				"While creating a PrefixListInValue value, an extra attribute value was detected. "+
					"A PrefixListInValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixListInValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixListInValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPrefixListInValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewPrefixListInValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewPrefixListInValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPrefixListInValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewPrefixListInValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewPrefixListInValueUnknown(), diags
	}

	return PrefixListInValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrefixListInValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixListInValue {
	object, diags := NewPrefixListInValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixListInValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixListInType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixListInValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixListInValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixListInValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixListInValueMust(PrefixListInValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixListInType) ValueType(ctx context.Context) attr.Value {
	return PrefixListInValue{}
}

var _ basetypes.ObjectValuable = PrefixListInValue{}

type PrefixListInValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v PrefixListInValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixListInValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixListInValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixListInValue) String() string {
	return "PrefixListInValue"
}

func (v PrefixListInValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v PrefixListInValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixListInValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v PrefixListInValue) Type(ctx context.Context) attr.Type {
	return PrefixListInType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixListInValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PrefixListOutType{}

type PrefixListOutType struct {
	basetypes.ObjectType
}

func (t PrefixListOutType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixListOutType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixListOutType) String() string {
	return "PrefixListOutType"
}

func (t PrefixListOutType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixListOutValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrefixListOutValueNull() PrefixListOutValue {
	return PrefixListOutValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixListOutValueUnknown() PrefixListOutValue {
	return PrefixListOutValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixListOutValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixListOutValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixListOutValue Attribute Value",
				"While creating a PrefixListOutValue value, a missing attribute value was detected. "+
					"A PrefixListOutValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixListOutValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixListOutValue Attribute Type",
				"While creating a PrefixListOutValue value, an invalid attribute value was detected. "+
					"A PrefixListOutValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixListOutValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixListOutValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixListOutValue Attribute Value",
				"While creating a PrefixListOutValue value, an extra attribute value was detected. "+
					"A PrefixListOutValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixListOutValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixListOutValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPrefixListOutValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewPrefixListOutValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewPrefixListOutValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPrefixListOutValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewPrefixListOutValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewPrefixListOutValueUnknown(), diags
	}

	return PrefixListOutValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrefixListOutValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixListOutValue {
	object, diags := NewPrefixListOutValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixListOutValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixListOutType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixListOutValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixListOutValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixListOutValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixListOutValueMust(PrefixListOutValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixListOutType) ValueType(ctx context.Context) attr.Value {
	return PrefixListOutValue{}
}

var _ basetypes.ObjectValuable = PrefixListOutValue{}

type PrefixListOutValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v PrefixListOutValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixListOutValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixListOutValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixListOutValue) String() string {
	return "PrefixListOutValue"
}

func (v PrefixListOutValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v PrefixListOutValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixListOutValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v PrefixListOutValue) Type(ctx context.Context) attr.Type {
	return PrefixListOutType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixListOutValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RemoteAddressType{}

type RemoteAddressType struct {
	basetypes.ObjectType
}

func (t RemoteAddressType) Equal(o attr.Type) bool {
	other, ok := o.(RemoteAddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemoteAddressType) String() string {
	return "RemoteAddressType"
}

func (t RemoteAddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	familyAttribute, ok := attributes["family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family is missing from object`)

		return nil, diags
	}

	familyVal, ok := familyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family expected to be basetypes.Int64Value, was: %T`, familyAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemoteAddressValue{
		Address:     addressVal,
		Description: descriptionVal,
		Display:     displayVal,
		Family:      familyVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRemoteAddressValueNull() RemoteAddressValue {
	return RemoteAddressValue{
		state: attr.ValueStateNull,
	}
}

func NewRemoteAddressValueUnknown() RemoteAddressValue {
	return RemoteAddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemoteAddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemoteAddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemoteAddressValue Attribute Value",
				"While creating a RemoteAddressValue value, a missing attribute value was detected. "+
					"A RemoteAddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteAddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemoteAddressValue Attribute Type",
				"While creating a RemoteAddressValue value, an invalid attribute value was detected. "+
					"A RemoteAddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteAddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemoteAddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemoteAddressValue Attribute Value",
				"While creating a RemoteAddressValue value, an extra attribute value was detected. "+
					"A RemoteAddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemoteAddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemoteAddressValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewRemoteAddressValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewRemoteAddressValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewRemoteAddressValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	familyAttribute, ok := attributes["family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family is missing from object`)

		return NewRemoteAddressValueUnknown(), diags
	}

	familyVal, ok := familyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family expected to be basetypes.Int64Value, was: %T`, familyAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewRemoteAddressValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewRemoteAddressValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewRemoteAddressValueUnknown(), diags
	}

	return RemoteAddressValue{
		Address:     addressVal,
		Description: descriptionVal,
		Display:     displayVal,
		Family:      familyVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRemoteAddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemoteAddressValue {
	object, diags := NewRemoteAddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemoteAddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemoteAddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemoteAddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemoteAddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemoteAddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemoteAddressValueMust(RemoteAddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemoteAddressType) ValueType(ctx context.Context) attr.Value {
	return RemoteAddressValue{}
}

var _ basetypes.ObjectValuable = RemoteAddressValue{}

type RemoteAddressValue struct {
	Address     basetypes.StringValue `tfsdk:"address"`
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Family      basetypes.Int64Value  `tfsdk:"family"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v RemoteAddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["family"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Family.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["family"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemoteAddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemoteAddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemoteAddressValue) String() string {
	return "RemoteAddressValue"
}

func (v RemoteAddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"address":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"family":      basetypes.Int64Type{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address":     v.Address,
			"description": v.Description,
			"display":     v.Display,
			"family":      v.Family,
			"id":          v.Id,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v RemoteAddressValue) Equal(o attr.Value) bool {
	other, ok := o.(RemoteAddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Family.Equal(other.Family) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v RemoteAddressValue) Type(ctx context.Context) attr.Type {
	return RemoteAddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemoteAddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"family":      basetypes.Int64Type{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RemoteAsType{}

type RemoteAsType struct {
	basetypes.ObjectType
}

func (t RemoteAsType) Equal(o attr.Type) bool {
	other, ok := o.(RemoteAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemoteAsType) String() string {
	return "RemoteAsType"
}

func (t RemoteAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return nil, diags
	}

	asnVal, ok := asnAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.Int64Value, was: %T`, asnAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemoteAsValue{
		Asn:         asnVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRemoteAsValueNull() RemoteAsValue {
	return RemoteAsValue{
		state: attr.ValueStateNull,
	}
}

func NewRemoteAsValueUnknown() RemoteAsValue {
	return RemoteAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemoteAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemoteAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemoteAsValue Attribute Value",
				"While creating a RemoteAsValue value, a missing attribute value was detected. "+
					"A RemoteAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemoteAsValue Attribute Type",
				"While creating a RemoteAsValue value, an invalid attribute value was detected. "+
					"A RemoteAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemoteAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemoteAsValue Attribute Value",
				"While creating a RemoteAsValue value, an extra attribute value was detected. "+
					"A RemoteAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemoteAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemoteAsValueUnknown(), diags
	}

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return NewRemoteAsValueUnknown(), diags
	}

	asnVal, ok := asnAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.Int64Value, was: %T`, asnAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewRemoteAsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewRemoteAsValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewRemoteAsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewRemoteAsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewRemoteAsValueUnknown(), diags
	}

	return RemoteAsValue{
		Asn:         asnVal,
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRemoteAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemoteAsValue {
	object, diags := NewRemoteAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemoteAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemoteAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemoteAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemoteAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemoteAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemoteAsValueMust(RemoteAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemoteAsType) ValueType(ctx context.Context) attr.Value {
	return RemoteAsValue{}
}

var _ basetypes.ObjectValuable = RemoteAsValue{}

type RemoteAsValue struct {
	Asn         basetypes.Int64Value  `tfsdk:"asn"`
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v RemoteAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["asn"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Asn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemoteAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemoteAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemoteAsValue) String() string {
	return "RemoteAsValue"
}

func (v RemoteAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"asn":         basetypes.Int64Type{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn":         v.Asn,
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v RemoteAsValue) Equal(o attr.Value) bool {
	other, ok := o.(RemoteAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Asn.Equal(other.Asn) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v RemoteAsValue) Type(ctx context.Context) attr.Type {
	return RemoteAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemoteAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn":         basetypes.Int64Type{},
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SiteType{}

type SiteType struct {
	basetypes.ObjectType
}

func (t SiteType) Equal(o attr.Type) bool {
	other, ok := o.(SiteType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SiteType) String() string {
	return "SiteType"
}

func (t SiteType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SiteValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Slug:        slugVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSiteValueNull() SiteValue {
	return SiteValue{
		state: attr.ValueStateNull,
	}
}

func NewSiteValueUnknown() SiteValue {
	return SiteValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSiteValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SiteValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SiteValue Attribute Value",
				"While creating a SiteValue value, a missing attribute value was detected. "+
					"A SiteValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SiteValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SiteValue Attribute Type",
				"While creating a SiteValue value, an invalid attribute value was detected. "+
					"A SiteValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SiteValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SiteValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SiteValue Attribute Value",
				"While creating a SiteValue value, an extra attribute value was detected. "+
					"A SiteValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SiteValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSiteValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSiteValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewSiteValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewSiteValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSiteValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewSiteValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSiteValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewSiteValueUnknown(), diags
	}

	return SiteValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Slug:        slugVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSiteValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SiteValue {
	object, diags := NewSiteValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSiteValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SiteType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSiteValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSiteValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSiteValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSiteValueMust(SiteValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SiteType) ValueType(ctx context.Context) attr.Value {
	return SiteValue{}
}

var _ basetypes.ObjectValuable = SiteValue{}

type SiteValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Slug        basetypes.StringValue `tfsdk:"slug"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v SiteValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SiteValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SiteValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SiteValue) String() string {
	return "SiteValue"
}

func (v SiteValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"slug":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"slug":        v.Slug,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v SiteValue) Equal(o attr.Value) bool {
	other, ok := o.(SiteValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v SiteValue) Type(ctx context.Context) attr.Type {
	return SiteType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SiteValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"slug":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return nil, diags
	}

	labelVal, ok := labelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be basetypes.StringValue, was: %T`, labelAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Label: labelVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	labelVal, ok := labelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be basetypes.StringValue, was: %T`, labelAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Label: labelVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Label basetypes.StringValue `tfsdk:"label"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["label"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Label.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["label"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"label": basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"label": v.Label,
			"value": v.Value,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Label.Equal(other.Label) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"label": basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TenantType{}

type TenantType struct {
	basetypes.ObjectType
}

func (t TenantType) Equal(o attr.Type) bool {
	other, ok := o.(TenantType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TenantType) String() string {
	return "TenantType"
}

func (t TenantType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TenantValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Slug:        slugVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTenantValueNull() TenantValue {
	return TenantValue{
		state: attr.ValueStateNull,
	}
}

func NewTenantValueUnknown() TenantValue {
	return TenantValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTenantValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TenantValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TenantValue Attribute Value",
				"While creating a TenantValue value, a missing attribute value was detected. "+
					"A TenantValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TenantValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TenantValue Attribute Type",
				"While creating a TenantValue value, an invalid attribute value was detected. "+
					"A TenantValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TenantValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TenantValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TenantValue Attribute Value",
				"While creating a TenantValue value, an extra attribute value was detected. "+
					"A TenantValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TenantValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTenantValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewTenantValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewTenantValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewTenantValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTenantValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewTenantValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewTenantValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewTenantValueUnknown(), diags
	}

	return TenantValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Slug:        slugVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTenantValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TenantValue {
	object, diags := NewTenantValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTenantValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TenantType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTenantValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTenantValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTenantValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTenantValueMust(TenantValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TenantType) ValueType(ctx context.Context) attr.Value {
	return TenantValue{}
}

var _ basetypes.ObjectValuable = TenantValue{}

type TenantValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Slug        basetypes.StringValue `tfsdk:"slug"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v TenantValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TenantValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TenantValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TenantValue) String() string {
	return "TenantValue"
}

func (v TenantValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"slug":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"slug":        v.Slug,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v TenantValue) Equal(o attr.Value) bool {
	other, ok := o.(TenantValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v TenantValue) Type(ctx context.Context) attr.Type {
	return TenantType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TenantValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"slug":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VirtualmachineType{}

type VirtualmachineType struct {
	basetypes.ObjectType
}

func (t VirtualmachineType) Equal(o attr.Type) bool {
	other, ok := o.(VirtualmachineType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VirtualmachineType) String() string {
	return "VirtualmachineType"
}

func (t VirtualmachineType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return nil, diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VirtualmachineValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVirtualmachineValueNull() VirtualmachineValue {
	return VirtualmachineValue{
		state: attr.ValueStateNull,
	}
}

func NewVirtualmachineValueUnknown() VirtualmachineValue {
	return VirtualmachineValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVirtualmachineValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VirtualmachineValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VirtualmachineValue Attribute Value",
				"While creating a VirtualmachineValue value, a missing attribute value was detected. "+
					"A VirtualmachineValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VirtualmachineValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VirtualmachineValue Attribute Type",
				"While creating a VirtualmachineValue value, an invalid attribute value was detected. "+
					"A VirtualmachineValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VirtualmachineValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VirtualmachineValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VirtualmachineValue Attribute Value",
				"While creating a VirtualmachineValue value, an extra attribute value was detected. "+
					"A VirtualmachineValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VirtualmachineValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVirtualmachineValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewVirtualmachineValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	displayAttribute, ok := attributes["display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display is missing from object`)

		return NewVirtualmachineValueUnknown(), diags
	}

	displayVal, ok := displayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display expected to be basetypes.StringValue, was: %T`, displayAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewVirtualmachineValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVirtualmachineValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewVirtualmachineValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewVirtualmachineValueUnknown(), diags
	}

	return VirtualmachineValue{
		Description: descriptionVal,
		Display:     displayVal,
		Id:          idVal,
		Name:        nameVal,
		Url:         urlVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVirtualmachineValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VirtualmachineValue {
	object, diags := NewVirtualmachineValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVirtualmachineValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VirtualmachineType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVirtualmachineValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVirtualmachineValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVirtualmachineValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVirtualmachineValueMust(VirtualmachineValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VirtualmachineType) ValueType(ctx context.Context) attr.Value {
	return VirtualmachineValue{}
}

var _ basetypes.ObjectValuable = VirtualmachineValue{}

type VirtualmachineValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Display     basetypes.StringValue `tfsdk:"display"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Url         basetypes.StringValue `tfsdk:"url"`
	state       attr.ValueState
}

func (v VirtualmachineValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Display.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VirtualmachineValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VirtualmachineValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VirtualmachineValue) String() string {
	return "VirtualmachineValue"
}

func (v VirtualmachineValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"display":     v.Display,
			"id":          v.Id,
			"name":        v.Name,
			"url":         v.Url,
		})

	return objVal, diags
}

func (v VirtualmachineValue) Equal(o attr.Value) bool {
	other, ok := o.(VirtualmachineValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Display.Equal(other.Display) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v VirtualmachineValue) Type(ctx context.Context) attr.Type {
	return VirtualmachineType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VirtualmachineValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"display":     basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"url":         basetypes.StringType{},
	}
}
